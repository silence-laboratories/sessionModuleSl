{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/browserWallet.ts"],"sourcesContent":["// lib/browserWallet.ts\nimport { TypedData, IBrowserWallet } from '@silencelaboratories/walletprovider-sdk';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { hashTypedData, hexToBytes, serializeSignature } from 'viem';\nimport { toHex } from 'viem/utils';\nimport { Buffer } from 'buffer';\n\nexport class BrowserWallet implements IBrowserWallet {\n  private privateKey: Uint8Array;\n\n  constructor(privateKeyHex: string) {\n    this.privateKey = Uint8Array.from(Buffer.from(privateKeyHex.replace(/^0x/, ''), 'hex'));\n  }\n\n  async signTypedData<T>(from: string, request: TypedData<T>): Promise<unknown> {\n    const castedRequest = {\n      ...request,\n      message: request.message as Record<string, unknown>,\n    };\n\n    // Create a hash of the typed data.\n    const messageHash = hashTypedData(castedRequest);\n    const messageBytes = hexToBytes(messageHash);\n\n    // Sign the hash.\n    const signature = secp256k1.sign(messageBytes, this.privateKey);\n\n    return serializeSignature({\n      r: toHex(signature.r),\n      s: toHex(signature.s),\n      v: BigInt(signature.recovery) + BigInt(27),\n    });\n  }\n}\n"],"names":[],"mappings":"AAAA,uBAAuB;;;;AAKvB;AAFA;AAAA;AADA;AACA;AACA;;;;;AAGO,MAAM;IACH,WAAuB;IAE/B,YAAY,aAAqB,CAAE;QACjC,IAAI,CAAC,UAAU,GAAG,WAAW,IAAI,CAAC,qGAAA,CAAA,SAAM,CAAC,IAAI,CAAC,cAAc,OAAO,CAAC,OAAO,KAAK;IAClF;IAEA,MAAM,cAAiB,IAAY,EAAE,OAAqB,EAAoB;QAC5E,MAAM,gBAAgB;YACpB,GAAG,OAAO;YACV,SAAS,QAAQ,OAAO;QAC1B;QAEA,mCAAmC;QACnC,MAAM,cAAc,CAAA,GAAA,mKAAA,CAAA,gBAAa,AAAD,EAAE;QAClC,MAAM,eAAe,CAAA,GAAA,4JAAA,CAAA,aAAU,AAAD,EAAE;QAEhC,iBAAiB;QACjB,MAAM,YAAY,qJAAA,CAAA,YAAS,CAAC,IAAI,CAAC,cAAc,IAAI,CAAC,UAAU;QAE9D,OAAO,CAAA,GAAA,wKAAA,CAAA,qBAAkB,AAAD,EAAE;YACxB,GAAG,CAAA,GAAA,0JAAA,CAAA,QAAK,AAAD,EAAE,UAAU,CAAC;YACpB,GAAG,CAAA,GAAA,0JAAA,CAAA,QAAK,AAAD,EAAE,UAAU,CAAC;YACpB,GAAG,OAAO,UAAU,QAAQ,IAAI,OAAO;QACzC;IACF;AACF"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/sl.ts"],"sourcesContent":["// lib/silenceLabs.ts\nimport { v4 as uuidv4 } from \"uuid\";\nimport { LocalAccount, privateKeyToAccount, toAccount, publicKeyToAddress } from 'viem/accounts';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport {\n  WalletProviderServiceClient,\n  EOAAuth,\n  EphKeyClaim,\n  generateEphPrivateKey,\n  getEphPublicKey,\n  NetworkSigner,\n  SignRequestBuilder,\n  EphAuth,\n  computeAddress,\n  SignResponse,\n} from \"@silencelaboratories/walletprovider-sdk\";\nimport { BrowserWallet } from \"./browserWallet\";\nimport { bytesToHex, stringToHex, toHex, keccak256, serializeSignature, serializeTransaction, hashTypedData, Signature, Hex } from \"viem\";\nimport { Base64 } from \"js-base64\";\n\n// Cluster configuration\nconst clusterConfig = {\n  walletProviderId: \"WalletProvider\",\n  walletProviderUrl: \"ws://34.118.117.249\", // update if needed\n  apiVersion: \"v1\",\n};\n\nconst THRESHOLD = 2;\nconst PARTIES_NUMBER = 3;\n\n// Key configuration interface\nexport interface KeyConfiguration {\n  publicKey: string;\n  keyId: string;\n  ephemeralKeyId: string;\n  // Store the ephemeral private key as a hex string (without 0x)\n  ephemeralPrivateKey: string;\n  signerAddress: string;\n  t: number;\n  n: number;\n  sessionAddress: string;\n}\n\n// Save/load key config from browser storage\nexport const saveKeyConfig = (config: KeyConfiguration) => {\n  localStorage.setItem(\"keyConfig\", JSON.stringify(config));\n};\n\nexport const loadKeyConfig = (): KeyConfiguration | null => {\n  const raw = localStorage.getItem(\"keyConfig\");\n  return raw ? JSON.parse(raw) : null;\n};\n\n// Utility: convert hex string to Uint8Array\nfunction hexToBytes(hexString: string): Uint8Array {\n  if (hexString.startsWith(\"0x\")) hexString = hexString.slice(2);\n  const bytes = new Uint8Array(hexString.length / 2);\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = parseInt(hexString.substr(i * 2, 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * generateCryptographicKey\n * Uses an EOAAuth flow (with a BrowserWallet) to generate the key pair.\n * Also generates an ephemeral key and then saves the key configuration in localStorage.\n */\nexport async function generateCryptographicKey(): Promise<{ keyConfig: KeyConfiguration; eoaNetworkSigner: NetworkSigner }> {\n  // Use a demo wallet private key (in production, obtain securely)\n  const demoWalletPrivateKey = \"0x6b17d0ae446c070ce14b12990cc10f5fcf89d3410277abea6f00352535502393\";\n  const browserWallet = new BrowserWallet(demoWalletPrivateKey);\n  const account = privateKeyToAccount(demoWalletPrivateKey);\n  const ownerAddress = account.address;\n\n  // Generate an ephemeral key for later signing\n  const algSign = \"secp256k1\";\n  const ephemeralPrivateKey = generateEphPrivateKey(algSign);\n  const ephemeralPublicKey = getEphPublicKey(ephemeralPrivateKey, algSign);\n  const ephId = uuidv4();\n  const ephClaim = new EphKeyClaim(ephId, ephemeralPublicKey, algSign, 60 * 60);\n\n  // Create the EOAAuth instance for key generation using the EOA (BrowserWallet)\n  const eoaAuth = new EOAAuth(ownerAddress, browserWallet, { ephClaim });\n\n  const walletProviderClient = new WalletProviderServiceClient({\n    walletProviderId: clusterConfig.walletProviderId,\n    walletProviderUrl: clusterConfig.walletProviderUrl,\n    apiVersion: \"v1\",\n  });\n\n  // Create network signer (using EOAAuth) to call generateKey\n  const eoaNetworkSigner = new NetworkSigner(walletProviderClient, THRESHOLD, PARTIES_NUMBER, eoaAuth);\n  const signAlg = \"secp256k1\";\n  const keygenResponse = await eoaNetworkSigner.generateKey([signAlg]);\n  const [primaryKey] = keygenResponse;\n  primaryKey.keyId = String(primaryKey.keyId);\n\n  console.log(\"Silence Labs keygen response:\", keygenResponse);\n\n  // Build key configuration object\n  const keyConfig: KeyConfiguration = {\n    publicKey: primaryKey.publicKey,\n    keyId: primaryKey.keyId,\n    ephemeralKeyId: ephId,\n    ephemeralPrivateKey: Buffer.from(ephemeralPrivateKey).toString(\"hex\"),\n    signerAddress: ownerAddress,\n    t: THRESHOLD,\n    n: PARTIES_NUMBER,\n    sessionAddress: computeAddress(primaryKey.publicKey),\n  };\n\n  // Store configuration in browser storage\n  saveKeyConfig(keyConfig);\n\n  return { keyConfig, eoaNetworkSigner };\n}\n\n/**\n * createSignerForSign\n * Loads the key configuration from localStorage and creates a NetworkSigner using EphAuth\n * for signing operations.\n */\nexport async function createSignerForSign(): Promise<{ networkSigner: NetworkSigner; keyId: string; publicKey: string }> {\n  const config = loadKeyConfig();\n  if (!config) {\n    throw new Error(\"Key configuration not found. Please generate keys first.\");\n  }\n  const ephemeralPrivateKeyBytes = hexToBytes(config.ephemeralPrivateKey);\n  const ephAuth = new EphAuth(config.ephemeralKeyId, ephemeralPrivateKeyBytes, \"secp256k1\");\n\n  const walletProviderClient = new WalletProviderServiceClient({\n    walletProviderId: clusterConfig.walletProviderId,\n    walletProviderUrl: clusterConfig.walletProviderUrl,\n    apiVersion: \"v1\",\n  });\n\n  const networkSigner = new NetworkSigner(walletProviderClient, config.t, config.n, ephAuth);\n  return { networkSigner, keyId: config.keyId, publicKey: config.publicKey };\n}\n\n/**\n * createViemAccount\n * Creates a Viem-compatible account object from the given network signer.\n */\nexport function createViemAccount(\n  networkSigner: NetworkSigner,\n  keyId: string,\n  publicKey: string,\n  signAlg: string = 'secp256k1',\n): LocalAccount {\n  const publicKeyHex = `0x${publicKey}`;\n  const address = publicKeyToAddress(publicKeyHex as `0x${string}`);\n  console.log(\"Generated MPC Address:\", address);\n  return toAccount({\n    address,\n    keyId,\n    async signMessage({ message }) {\n      console.log(\"signMessage\", message);\n      message = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (typeof message.raw === \"string\") {\n          return message.raw;\n        }\n        return bytesToHex(message.raw);\n      })();\n      if (message.slice(0, 2) === \"0x\") {\n        message = message.slice(2);\n      }\n      console.log(\"Processed message:\", message);\n      const signRequest = new SignRequestBuilder()\n        .setRequest(uuidv4(), message, \"rawBytes\")\n        .build();\n      console.log(\"Sign Request:\", signRequest);\n      console.log(\"Using network signer:\", networkSigner);\n      const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n      console.log(\"Signature response:\", sign);\n      if (sign) {\n        const signature = formatViemSign(sign);\n        return serializeSignature(signature);\n      }\n      throw new Error('No signature returned from network');\n    },\n    async signTransaction(transaction, args) {\n      console.log(\"Sign Transaction\", transaction);\n      const serializer = args?.serializer || serializeTransaction;\n      const signableTransaction = (() => {\n        if (transaction.type === 'eip4844') {\n          return { ...transaction, sidecars: false };\n        }\n        return transaction;\n      })();\n      const signRequest = new SignRequestBuilder()\n        .setRequest(address, keccak256(serializer(signableTransaction)), 'EIP191')\n        .build();\n      const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n      if (sign) {\n        const signature = formatViemSign(sign);\n        return serializer(transaction, signature);\n      }\n      throw new Error('No signature returned from network');\n    },\n    async signTypedData(typedData) {\n      console.log(\"Sign Typed Data\", typedData);\n      const signRequest = new SignRequestBuilder()\n        .setRequest(address, hashTypedData(typedData), 'EIP712')\n        .build();\n      const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n      if (sign) {\n        const signature = formatViemSign(sign);\n        return serializeSignature(signature);\n      }\n      throw new Error('No signature returned from network');\n    },\n  });\n}\n\nfunction formatViemSign(signResp: SignResponse): Signature {\n  const sign =  signResp.sign\n  const hexSig = sign.startsWith(\"0x\") ? sign.slice(2) : sign;\n  const r = \"0x\" + hexSig.slice(0, 64) as Hex; // first 64 hex characters = 32 bytes\n  const s = \"0x\" + hexSig.slice(64, 128) as Hex; // next 64 hex characters = 32 bytes\n  const recid = signResp.recid;\n  const signature = {\n    r,\n    s,\n    v: recid === 0 ? BigInt(27) : BigInt(28),\n    yParity: recid,\n  };\n  return signature;\n}\n"],"names":[],"mappings":"AAAA,qBAAqB;;;;;;;;AAIrB;AAYA;AAdA;AADA;AACA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA,wBAAwB;AACxB,MAAM,gBAAgB;IACpB,kBAAkB;IAClB,mBAAmB;IACnB,YAAY;AACd;AAEA,MAAM,YAAY;AAClB,MAAM,iBAAiB;AAgBhB,MAAM,gBAAgB,CAAC;IAC5B,aAAa,OAAO,CAAC,aAAa,KAAK,SAAS,CAAC;AACnD;AAEO,MAAM,gBAAgB;IAC3B,MAAM,MAAM,aAAa,OAAO,CAAC;IACjC,OAAO,MAAM,KAAK,KAAK,CAAC,OAAO;AACjC;AAEA,4CAA4C;AAC5C,SAAS,WAAW,SAAiB;IACnC,IAAI,UAAU,UAAU,CAAC,OAAO,YAAY,UAAU,KAAK,CAAC;IAC5D,MAAM,QAAQ,IAAI,WAAW,UAAU,MAAM,GAAG;IAChD,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACrC,KAAK,CAAC,EAAE,GAAG,SAAS,UAAU,MAAM,CAAC,IAAI,GAAG,IAAI;IAClD;IACA,OAAO;AACT;AAOO,eAAe;IACpB,iEAAiE;IACjE,MAAM,uBAAuB;IAC7B,MAAM,gBAAgB,IAAI,oHAAA,CAAA,gBAAa,CAAC;IACxC,MAAM,UAAU,CAAA,GAAA,+JAAA,CAAA,sBAAmB,AAAD,EAAE;IACpC,MAAM,eAAe,QAAQ,OAAO;IAEpC,8CAA8C;IAC9C,MAAM,UAAU;IAChB,MAAM,sBAAsB,CAAA,GAAA,sLAAA,CAAA,wBAAqB,AAAD,EAAE;IAClD,MAAM,qBAAqB,CAAA,GAAA,sLAAA,CAAA,kBAAe,AAAD,EAAE,qBAAqB;IAChE,MAAM,QAAQ,CAAA,GAAA,0KAAA,CAAA,KAAM,AAAD;IACnB,MAAM,WAAW,IAAI,sLAAA,CAAA,cAAW,CAAC,OAAO,oBAAoB,SAAS,KAAK;IAE1E,+EAA+E;IAC/E,MAAM,UAAU,IAAI,sLAAA,CAAA,UAAO,CAAC,cAAc,eAAe;QAAE;IAAS;IAEpE,MAAM,uBAAuB,IAAI,sLAAA,CAAA,8BAA2B,CAAC;QAC3D,kBAAkB,cAAc,gBAAgB;QAChD,mBAAmB,cAAc,iBAAiB;QAClD,YAAY;IACd;IAEA,4DAA4D;IAC5D,MAAM,mBAAmB,IAAI,sLAAA,CAAA,gBAAa,CAAC,sBAAsB,WAAW,gBAAgB;IAC5F,MAAM,UAAU;IAChB,MAAM,iBAAiB,MAAM,iBAAiB,WAAW,CAAC;QAAC;KAAQ;IACnE,MAAM,CAAC,WAAW,GAAG;IACrB,WAAW,KAAK,GAAG,OAAO,WAAW,KAAK;IAE1C,QAAQ,GAAG,CAAC,iCAAiC;IAE7C,iCAAiC;IACjC,MAAM,YAA8B;QAClC,WAAW,WAAW,SAAS;QAC/B,OAAO,WAAW,KAAK;QACvB,gBAAgB;QAChB,qBAAqB,OAAO,IAAI,CAAC,qBAAqB,QAAQ,CAAC;QAC/D,eAAe;QACf,GAAG;QACH,GAAG;QACH,gBAAgB,CAAA,GAAA,sLAAA,CAAA,iBAAc,AAAD,EAAE,WAAW,SAAS;IACrD;IAEA,yCAAyC;IACzC,cAAc;IAEd,OAAO;QAAE;QAAW;IAAiB;AACvC;AAOO,eAAe;IACpB,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,2BAA2B,WAAW,OAAO,mBAAmB;IACtE,MAAM,UAAU,IAAI,sLAAA,CAAA,UAAO,CAAC,OAAO,cAAc,EAAE,0BAA0B;IAE7E,MAAM,uBAAuB,IAAI,sLAAA,CAAA,8BAA2B,CAAC;QAC3D,kBAAkB,cAAc,gBAAgB;QAChD,mBAAmB,cAAc,iBAAiB;QAClD,YAAY;IACd;IAEA,MAAM,gBAAgB,IAAI,sLAAA,CAAA,gBAAa,CAAC,sBAAsB,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE;IAClF,OAAO;QAAE;QAAe,OAAO,OAAO,KAAK;QAAE,WAAW,OAAO,SAAS;IAAC;AAC3E;AAMO,SAAS,kBACd,aAA4B,EAC5B,KAAa,EACb,SAAiB,EACjB,UAAkB,WAAW;IAE7B,MAAM,eAAe,CAAC,EAAE,EAAE,WAAW;IACrC,MAAM,UAAU,CAAA,GAAA,uKAAA,CAAA,qBAAkB,AAAD,EAAE;IACnC,QAAQ,GAAG,CAAC,0BAA0B;IACtC,OAAO,CAAA,GAAA,qJAAA,CAAA,YAAS,AAAD,EAAE;QACf;QACA;QACA,MAAM,aAAY,EAAE,OAAO,EAAE;YAC3B,QAAQ,GAAG,CAAC,eAAe;YAC3B,UAAU,CAAC;gBACT,IAAI,OAAO,YAAY,UAAU;oBAC/B,OAAO,CAAA,GAAA,0JAAA,CAAA,cAAW,AAAD,EAAE;gBACrB;gBACA,IAAI,OAAO,QAAQ,GAAG,KAAK,UAAU;oBACnC,OAAO,QAAQ,GAAG;gBACpB;gBACA,OAAO,CAAA,GAAA,0JAAA,CAAA,aAAU,AAAD,EAAE,QAAQ,GAAG;YAC/B,CAAC;YACD,IAAI,QAAQ,KAAK,CAAC,GAAG,OAAO,MAAM;gBAChC,UAAU,QAAQ,KAAK,CAAC;YAC1B;YACA,QAAQ,GAAG,CAAC,sBAAsB;YAClC,MAAM,cAAc,IAAI,sLAAA,CAAA,qBAAkB,GACvC,UAAU,CAAC,CAAA,GAAA,0KAAA,CAAA,KAAM,AAAD,KAAK,SAAS,YAC9B,KAAK;YACR,QAAQ,GAAG,CAAC,iBAAiB;YAC7B,QAAQ,GAAG,CAAC,yBAAyB;YACrC,MAAM,OAAO,CAAC,MAAM,cAAc,WAAW,CAAC,OAAO,SAAS,YAAY,CAAC,CAAC,EAAE;YAC9E,QAAQ,GAAG,CAAC,uBAAuB;YACnC,IAAI,MAAM;gBACR,MAAM,YAAY,eAAe;gBACjC,OAAO,CAAA,GAAA,wKAAA,CAAA,qBAAkB,AAAD,EAAE;YAC5B;YACA,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,iBAAgB,WAAW,EAAE,IAAI;YACrC,QAAQ,GAAG,CAAC,oBAAoB;YAChC,MAAM,aAAa,MAAM,cAAc,4KAAA,CAAA,uBAAoB;YAC3D,MAAM,sBAAsB,CAAC;gBAC3B,IAAI,YAAY,IAAI,KAAK,WAAW;oBAClC,OAAO;wBAAE,GAAG,WAAW;wBAAE,UAAU;oBAAM;gBAC3C;gBACA,OAAO;YACT,CAAC;YACD,MAAM,cAAc,IAAI,sLAAA,CAAA,qBAAkB,GACvC,UAAU,CAAC,SAAS,CAAA,GAAA,0JAAA,CAAA,YAAS,AAAD,EAAE,WAAW,uBAAuB,UAChE,KAAK;YACR,MAAM,OAAO,CAAC,MAAM,cAAc,WAAW,CAAC,OAAO,SAAS,YAAY,CAAC,CAAC,EAAE;YAC9E,IAAI,MAAM;gBACR,MAAM,YAAY,eAAe;gBACjC,OAAO,WAAW,aAAa;YACjC;YACA,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,eAAc,SAAS;YAC3B,QAAQ,GAAG,CAAC,mBAAmB;YAC/B,MAAM,cAAc,IAAI,sLAAA,CAAA,qBAAkB,GACvC,UAAU,CAAC,SAAS,CAAA,GAAA,mKAAA,CAAA,gBAAa,AAAD,EAAE,YAAY,UAC9C,KAAK;YACR,MAAM,OAAO,CAAC,MAAM,cAAc,WAAW,CAAC,OAAO,SAAS,YAAY,CAAC,CAAC,EAAE;YAC9E,IAAI,MAAM;gBACR,MAAM,YAAY,eAAe;gBACjC,OAAO,CAAA,GAAA,wKAAA,CAAA,qBAAkB,AAAD,EAAE;YAC5B;YACA,MAAM,IAAI,MAAM;QAClB;IACF;AACF;AAEA,SAAS,eAAe,QAAsB;IAC5C,MAAM,OAAQ,SAAS,IAAI;IAC3B,MAAM,SAAS,KAAK,UAAU,CAAC,QAAQ,KAAK,KAAK,CAAC,KAAK;IACvD,MAAM,IAAI,OAAO,OAAO,KAAK,CAAC,GAAG,KAAY,qCAAqC;IAClF,MAAM,IAAI,OAAO,OAAO,KAAK,CAAC,IAAI,MAAa,oCAAoC;IACnF,MAAM,QAAQ,SAAS,KAAK;IAC5B,MAAM,YAAY;QAChB;QACA;QACA,GAAG,UAAU,IAAI,OAAO,MAAM,OAAO;QACrC,SAAS;IACX;IACA,OAAO;AACT"}},
    {"offset": {"line": 267, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/src/app/page.tsx"],"sourcesContent":["// // app/page.tsx\n// \"use client\";\n// import { useState } from 'react';\n// import {\n//   createSmartAccountClient,\n//   toNexusAccount,\n//   smartSessionCreateActions,\n//   toSmartSessionsValidator,\n//   smartSessionUseActions,\n//   stringify,\n//   parse,\n//   SmartSessionMode,\n//   CreateSessionDataParams,\n// } from \"@biconomy/abstractjs\";\n// import { baseSepolia } from \"viem/chains\";\n// import { http, encodeFunctionData } from \"viem\";\n// import { createViemAccount, generateCryptographicKey, createSignerForSign } from '../../lib/sl';\n// import abi from './../../contracts/ABI.json';\n// import { privateKeyToAccount } from 'viem/accounts';\n// import { ethers } from 'ethers';\n\n// export default function SessionPage() {\n//   const [mpcSigner, setMpcSigner] = useState<any>(null);\n//   const [sessionData, setSessionData] = useState<string | null>(null);\n//   const [loading, setLoading] = useState<string>('');\n//   const [txHash, setTxHash] = useState<string>('');\n\n//   // Initialize MPC Signer: generate keys (if needed) and then create the signer for signing\n//   const initializeMPCSigner = async () => {\n//     setLoading('Initializing MPC signer...');\n//     try {\n//       // Generate key pair (this will store config in localStorage)\n//       await generateCryptographicKey();\n//       // Create a NetworkSigner using EphAuth for signing operations\n//       const { networkSigner, keyId, publicKey } = await createSignerForSign();\n//       const mpcAccount = createViemAccount(networkSigner, keyId, publicKey);\n//       setMpcSigner(mpcAccount);\n//       setLoading('');\n//     } catch (error) {\n//       console.error('MPC Signer Error:', error);\n//       setLoading('');\n//     }\n//   };\n\n//   // Create Biconomy Smart Session\n//   const createSmartSession = async () => {\n//     if (!mpcSigner) return;\n//     setLoading('Creating smart session...');\n\n//     try {\n//       // Initialize Nexus client with owner account\n//       const ownerPrivateKey = \"0xec2387b319f9c96c5f2a3f9f5152208d09c0265d139235cab9c90511e6836fc7\"; // Replace with actual owner key\n//       const ownerAccount = privateKeyToAccount(ownerPrivateKey);\n\n//       const bundlerUrl = \"https://bundler.biconomy.io/api/v3/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44\";\n//       const ownerAccountAddress = ownerAccount.address;\n//       console.log(\"Owner Account:\", ownerAccountAddress);\n//       const nexusClient = await createSmartAccountClient({\n//         account: await toNexusAccount({\n//           signer: ownerAccount,\n//           chain: baseSepolia,\n//           transport: http(),\n//         }),\n//         transport: http(bundlerUrl),\n//       });\n//       console.log(\"Nexus Client:\", nexusClient.account.address);\n\n//       // Create and install sessions module\n//       const sessionsModule = toSmartSessionsValidator({\n//         account: nexusClient.account,\n//         signer: ownerAccount\n//       });\n//       console.log(\"Sessions Module:\", sessionsModule.moduleInitData);\n\n//       const hash = await nexusClient.installModule({\n//         module: sessionsModule.moduleInitData\n//       });\n//       console.log(\"Module Installation Hash:\", hash);\n\n//       await nexusClient.waitForUserOperationReceipt({ hash });\n\n//       const nexusSessionClient = nexusClient.extend(smartSessionCreateActions(sessionsModule));\n\n//       // Create session with MPC public key\n//       const sessionRequestedInfo: CreateSessionDataParams[] = [\n//         {\n//           sessionKeyData: mpcSigner.address as `0x${string}`,\n//           actionPoliciesInfo: [{\n//             contractAddress: \"0x7961d826258946969fa0d80b34508094c6148bdf\" as `0x${string}`,\n//             rules: [],\n//             functionSelector: \"0xd09de08a\" as `0x${string}` // Function selector for 'increment'\n//           }]\n//         }\n//       ];\n//       console.log(\"sessionRequestedInfo:\", sessionRequestedInfo);\n\n//       const createSessionsResponse = await nexusSessionClient.grantPermission({\n//         sessionRequestedInfo\n//       });\n\n//       await nexusClient.waitForUserOperationReceipt({\n//         hash: createSessionsResponse.userOpHash\n//       });\n\n//       // Store session data in localStorage for persistence\n//       const sessionDataObj = {\n//         granter: nexusClient.account.address,\n//         sessionPublicKey: mpcSigner.address,\n//         description: `MPC Session for ${nexusClient.account.address.slice(0, 6)}`,\n//         moduleData: {\n//           ...createSessionsResponse,\n//           mode: SmartSessionMode.USE\n//         }\n//       };\n\n//       const compressedData = stringify(sessionDataObj);\n//       localStorage.setItem('mpcSessionData', compressedData);\n//       setSessionData(compressedData);\n//       setLoading('');\n//     } catch (error) {\n//       console.error('Session Creation Error:', error);\n//       setLoading('');\n//     }\n//   };\n\n//   // Execute Transaction with MPC Session\n//   const executeTransaction = async () => {\n//     if (!sessionData) return;\n//     setLoading('Executing transaction...');\n\n//     try {\n//       const parsedData = parse(sessionData);\n//       const bundlerUrl = \"https://bundler.biconomy.io/api/v3/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44\";\n\n//       // Create MPC-powered client\n//       console.log(\"Creating MPC-powered client...\");\n//       const smartSessionClient = createSmartAccountClient({\n//         chain: baseSepolia,\n//         account: await toNexusAccount({\n//           signer: mpcSigner,\n//           chain: baseSepolia,\n//           transport: http(),\n//         }),\n//         transport: http(bundlerUrl)\n//       });\n\n//       // Attach sessions module\n//       console.log(\"Attaching sessions module...\");\n//       const usePermissionsModule = toSmartSessionsValidator({\n//         account: smartSessionClient.account,\n//         signer: mpcSigner,\n//         moduleData: parsedData.moduleData\n//       });\n\n//       const sessionEnabledClient = smartSessionClient.extend(\n//         smartSessionUseActions(usePermissionsModule)\n//       );\n\n//       // Execute transaction (example: calling 'increment')\n//       console.log(\"Executing transaction...\");\n//       const userOpHash = await sessionEnabledClient.usePermission({\n//         calls: [{\n//           to: \"0x7961d826258946969fa0d80b34508094c6148bdf\",\n//           data: encodeFunctionData({\n//             abi: abi,\n//             functionName: \"increment\"\n//           })\n//         }],\n//         callGasLimit: BigInt(100000),\n//         verificationGasLimit: BigInt(500000),\n//         preVerificationGas: BigInt(300000)\n\n//       });\n\n//       setTxHash(userOpHash);\n//       setLoading('');\n//     } catch (error) {\n//       console.error('Execution Error:', error);\n//       setLoading('');\n//     }\n//   };\n\n//   return (\n//     <div className=\"min-h-screen p-8\">\n//       <h1 className=\"text-3xl mb-8\">MPC-Powered Smart Sessions</h1>\n\n//       <div className=\"space-y-4 max-w-2xl\">\n//         <button\n//           onClick={initializeMPCSigner}\n//           className=\"btn-primary\"\n//           disabled={!!mpcSigner}\n//         >\n//           {mpcSigner ? 'MPC Signer Ready' : 'Initialize MPC Signer'}\n//         </button>\n\n//         {mpcSigner && (\n//           <button\n//             onClick={createSmartSession}\n//             className=\"btn-secondary\"\n//             disabled={!!sessionData}\n//           >\n//             {sessionData ? 'Session Created' : 'Create Smart Session'}\n//           </button>\n//         )}\n\n//         {sessionData && (\n//           <button\n//             onClick={executeTransaction}\n//             className=\"btn-success\"\n//           >\n//             Execute Transaction\n//           </button>\n//         )}\n\n//         {loading && <p className=\"text-blue-500\">{loading}</p>}\n//         {txHash && (\n//           <div className=\"mt-4 p-4 bg-gray-100 rounded\">\n//             <p className=\"font-mono break-words\">Transaction Hash: {txHash}</p>\n//           </div>\n//         )}\n\n//         <div className=\"mt-8 space-y-2\">\n//           {mpcSigner && (\n//             <p>MPC Signer Address: {mpcSigner.address}</p>\n//           )}\n//           {sessionData && (\n//             <p>Session Granter: {parse(sessionData).granter}</p>\n//           )}\n//         </div>\n//       </div>\n//     </div>\n//   );\n// }\n\nimport { useState } from \"react\";\nimport { generateCryptographicKey, createSignerForSign, createViemAccount } from \"../../lib/sl\";\nimport { baseSepolia } from \"viem/chains\";\nimport { createPublicClient, createWalletClient, encodeFunctionData, http } from \"viem\";\n\n// 1. Replace with your actual contract ABI and address\nconst CounterAbi = [\n  {\n    inputs: [],\n    name: \"incrementNumber\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n];\nconst CONTRACT_ADDRESS = \"0x7961d826258946969fa0d80b34508094c6148bdf\"; // REPLACE WITH YOUR DEPLOYED CONTRACT ADDRESS\n\nexport default function HomePage() {\n  const [loading, setLoading] = useState(false);\n  const [txHash, setTxHash] = useState<string | null>(null);\n  const [mpcAddress, setMpcAddress] = useState<string | null>(null);\n\n  const initializeMPCAccount = async () => {\n    try {\n      setLoading(true);\n      // Generate MPC account using Silence Labs\n      const { keyConfig } = await generateCryptographicKey();\n      setMpcAddress(keyConfig.sessionAddress);\n      \n      // In production: Implement logic to fund the MPC address here\n      console.log(\"Fund this MPC address:\", keyConfig.sessionAddress);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const sendTransaction = async () => {\n    if (!mpcAddress) return;\n\n    try {\n      setLoading(true);\n      \n      // 2. Create signer and Viem account\n      const { networkSigner, keyId, publicKey } = await createSignerForSign();\n      const mpcAccount = createViemAccount(networkSigner, keyId, publicKey);\n\n      // 3. Create wallet client with MPC account\n      const walletClient = createWalletClient({\n        account: mpcAccount,\n        chain: baseSepolia,\n        transport: http()\n      });\n\n      // 4. Create public client for network interactions\n      const publicClient = createPublicClient({\n        chain: baseSepolia,\n        transport: http()\n      });\n\n      // 5. Send transaction directly\n      const hash = await walletClient.sendTransaction({\n              account: mpcAccount,\n              to: CONTRACT_ADDRESS as `0x${string}`,\n              data: encodeFunctionData({\n                abi: CounterAbi,\n                functionName: \"incrementNumber\"\n              }),\n              gas: BigInt(100000) // Adjust based on contract requirements\n            });\n\n      setTxHash(hash);\n      \n      // Wait for confirmation\n      const receipt = await publicClient.waitForTransactionReceipt({ hash });\n      console.log(\"Transaction confirmed:\", receipt);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div>\n      <h1>MPC Transaction Demo</h1>\n      \n      {!mpcAddress && (\n        <button onClick={initializeMPCAccount} disabled={loading}>\n          {loading ? \"Initializing...\" : \"Initialize MPC Account\"}\n        </button>\n      )}\n\n      {mpcAddress && (\n        <div>\n          <p>MPC Address: {mpcAddress}</p>\n          <p>⚠️ Fund this address with Base Sepolia ETH ⚠️</p>\n          \n          <button onClick={sendTransaction} disabled={loading}>\n            {loading ? \"Sending...\" : \"Send Increment Transaction\"}\n          </button>\n        </div>\n      )}\n\n      {txHash && (\n        <div>\n          <h3>Transaction Successful!</h3>\n          <p>Hash: {txHash}</p>\n          <a\n            href={`https://sepolia.basescan.org/tx/${txHash}`}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            View on Explorer\n          </a>\n        </div>\n      )}\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 653, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 664, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 664, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}