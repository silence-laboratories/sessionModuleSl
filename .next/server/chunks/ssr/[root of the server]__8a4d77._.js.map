{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/sl.ts"],"sourcesContent":["// sl.ts\nimport { v4 as uuidv4 } from \"uuid\";\nimport { privateKeyToAccount, publicKeyToAddress, toAccount } from 'viem/accounts';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport {\n  WalletProviderServiceClient,\n  EOAAuth,\n  EphKeyClaim,\n  generateEphPrivateKey,\n  getEphPublicKey,\n  NetworkSigner,\n  SignRequestBuilder,\n  EphAuth,\n  computeAddress,\n  SignResponse,\n} from \"@silencelaboratories/walletprovider-sdk\";\nimport {\n  bytesToHex,\n  stringToHex,\n  toPrefixedMessage,\n  keccak256,\n  serializeSignature,\n  serializeTransaction,\n  hashTypedData,\n  Signature,\n  Hex,\n  recoverAddress,\n  hashMessage,\n} from \"viem\";\n\n// (1) Silence Labs cluster config\nconst clusterConfig = {\n  walletProviderId: \"WalletProvider\",\n  walletProviderUrl: \"ws://34.118.117.249\",\n  apiVersion: \"v1\",\n};\n\n// (2) Keygen parameters\nconst THRESHOLD = 2;\nconst PARTIES_NUMBER = 3;\n\n// (3) Demo EOA private key for your “owner” – in production, handle securely\nconst DEMO_WALLET_PRIVATE_KEY =\n  \"0x6b17d0ae446c070ce14b12990cc10f5fcf89d3410277abea6f00352535502393\";\n\n// (4) In-memory variables (no LocalStorage)\nlet ephemeralPrivateKey: Uint8Array | null = null;\nlet ephemeralKeyId: string | null = null;\nlet primaryKeyPublic: string | null = null;\nlet primaryKeyId: string | null = null;\nlet signerAddress: string | null = null;\n\n/**\n * generateCryptographicKey\n * 1. Creates ephemeral key\n * 2. Uses the “demo wallet” EOA + EOAAuth to run generateKey on Silence Labs\n * 3. Caches ephemeral + result in memory (no localStorage).\n */\nexport async function generateCryptographicKey(): Promise<void> {\n  // 1. Prep a “BrowserWallet-like” EOA for the EOAAuth\n  const eoaAccount = privateKeyToAccount(DEMO_WALLET_PRIVATE_KEY);\n  signerAddress = eoaAccount.address;\n\n  // 2. Generate ephemeral key\n  const algSign = \"secp256k1\";\n  ephemeralPrivateKey = generateEphPrivateKey(algSign);\n  const ephemeralPublicKey = getEphPublicKey(ephemeralPrivateKey, algSign);\n  ephemeralKeyId = uuidv4();\n\n  // Claim is only needed if you want ephemeral key recognized by the server\n  // This example sets TTL = 1 hour, adjust as needed\n  const ephClaim = new EphKeyClaim(ephemeralKeyId, ephemeralPublicKey, algSign, 60 * 60);\n\n  // 3. Build EOAAuth\n  const eoaAuth = new EOAAuth(signerAddress, {\n    async signMessage(msg: string | Uint8Array) {\n      // Example minimal sign\n      return eoaAccount.signMessage({ message: msg });\n    }\n  }, { ephClaim });\n\n  // 4. Connect Silence Labs WebSocket client\n  const walletProviderClient = new WalletProviderServiceClient({\n    walletProviderId: clusterConfig.walletProviderId,\n    walletProviderUrl: clusterConfig.walletProviderUrl,\n    apiVersion: clusterConfig.apiVersion,\n  });\n\n  // 5. Use EOAAuth to create a NetworkSigner\n  const eoaNetworkSigner = new NetworkSigner(\n    walletProviderClient,\n    THRESHOLD,\n    PARTIES_NUMBER,\n    eoaAuth\n  );\n\n  // 6. Keygen request\n  const keygenResponse = await eoaNetworkSigner.generateKey([algSign]);\n  const [primaryKey] = keygenResponse;\n\n  // Silence Labs typically returns numeric IDs; ensure they're strings if needed\n  primaryKey.keyId = String(primaryKey.keyId);\n\n  // 7. Cache returned publicKey + keyId in memory\n  primaryKeyPublic = primaryKey.publicKey;\n  primaryKeyId = primaryKey.keyId;\n}\n\n/**\n * createSignerForSign\n * Creates a NetworkSigner that uses the ephemeral key (EphAuth) in memory,\n * referencing the previously generated Silence Labs key.\n */\nexport async function createSignerForSign(): Promise<{\n  networkSigner: NetworkSigner;\n  keyId: string;\n  publicKey: string;\n}> {\n  if (!ephemeralPrivateKey || !ephemeralKeyId) {\n    throw new Error(\"Ephemeral key not found. Did you call generateCryptographicKey() first?\");\n  }\n  if (!primaryKeyPublic || !primaryKeyId) {\n    throw new Error(\"No primary MPC key found. Did you call generateCryptographicKey() first?\");\n  }\n\n  // Build ephemeral-auth\n  const ephAuth = new EphAuth(ephemeralKeyId, ephemeralPrivateKey, \"secp256k1\");\n\n  const walletProviderClient = new WalletProviderServiceClient({\n    walletProviderId: clusterConfig.walletProviderId,\n    walletProviderUrl: clusterConfig.walletProviderUrl,\n    apiVersion: clusterConfig.apiVersion,\n  });\n\n  const networkSigner = new NetworkSigner(\n    walletProviderClient,\n    THRESHOLD,\n    PARTIES_NUMBER,\n    ephAuth\n  );\n\n  return {\n    networkSigner,\n    keyId: primaryKeyId,\n    publicKey: primaryKeyPublic,\n  };\n}\n\n/**\n * createViemAccount\n * Helper that returns a viem-compatible LocalAccount for signing\n * with the Silence Labs MPC keys.\n */\nexport function createViemAccount(\n  networkSigner: NetworkSigner,\n  keyId: string,\n  publicKey: string,\n  signAlg: string = 'secp256k1',\n) {\n  const publicKeyHex = `0x${publicKey}`;\n  const address = publicKeyToAddress(publicKeyHex as `0x${string}`);\n\n  console.log(\"MPC Address:\", address);\n\n  return toAccount({\n    address,\n    keyId,\n\n    async signMessage({ message }) {\n      // 1) Convert message to hex\n      let processedMessage =\n        typeof message === \"string\"\n          ? stringToHex(message)\n          : bytesToHex(message.raw);\n\n      // 2) Strip 0x if present\n      if (processedMessage.startsWith(\"0x\")) {\n        processedMessage = processedMessage.slice(2);\n      }\n\n      // 3) Check if the message is a 32-byte hash\n      const isHash = processedMessage.length === 64;\n\n      // 4) For non-hash messages, apply the \"\\x19Ethereum Signed Message\" prefix\n      const finalMessage = isHash\n        ? processedMessage\n        : toPrefixedMessage(processedMessage).slice(2);\n\n      // 5) Build the Silence Labs sign request\n      const signRequest = new SignRequestBuilder()\n        .setRequest(uuidv4(), finalMessage, \"rawBytes\")\n        .build();\n\n      // 6) Ask the networkSigner to sign\n      const [sign] = await networkSigner.signMessage(keyId, signAlg, signRequest);\n\n      // 7) Recover to check correctness\n      const verifiedAddress = recoverAddress({\n        hash: hashMessage(finalMessage),\n        signature: serializeSignature(formatViemSign(sign)),\n      });\n      if (verifiedAddress !== address) {\n        throw new Error(\"Signature verification failed\");\n      }\n      return serializeSignature(formatViemSign(sign));\n    },\n\n    async signTransaction(transaction, args) {\n      const serializer = args?.serializer || serializeTransaction;\n      const signableTransaction =\n        transaction.type === 'eip4844'\n          ? { ...transaction, sidecars: false }\n          : transaction;\n\n      // EIP-191 sign of the transaction hash\n      const signRequest = new SignRequestBuilder()\n        .setRequest(\n          address,\n          keccak256(serializer(signableTransaction)),\n          'EIP191'\n        )\n        .build();\n\n      const [sign] = await networkSigner.signMessage(keyId, signAlg, signRequest);\n      if (!sign) throw new Error(\"No signature returned from network\");\n\n      const signature = formatViemSign(sign);\n      return serializer(transaction, signature);\n    },\n\n    async signTypedData(typedData) {\n      const signRequest = new SignRequestBuilder()\n        .setRequest(address, hashTypedData(typedData), 'EIP712')\n        .build();\n\n      const [sign] = await networkSigner.signMessage(keyId, signAlg, signRequest);\n      if (!sign) {\n        throw new Error(\"No signature returned from network\");\n      }\n\n      const signature = formatViemSign(sign);\n      return serializeSignature(signature);\n    },\n  });\n}\n\n/**\n * formatViemSign\n * Takes a Silence Labs SignResponse and reshapes it to viem’s { v,r,s } format.\n */\nfunction formatViemSign(signResp: SignResponse): Signature {\n  const hexSig = signResp.sign.startsWith(\"0x\")\n    ? signResp.sign.slice(2)\n    : signResp.sign;\n\n  const r = \"0x\" + hexSig.slice(0, 64) as Hex;\n  const s = \"0x\" + hexSig.slice(64, 128) as Hex;\n  const recid = signResp.recid;\n\n  return {\n    r,\n    s,\n    v: BigInt(recid), // 0 or 1\n    yParity: recid,   // For EIP-155\n  };\n}\n"],"names":[],"mappings":"AAAA,QAAQ;;;;;;AAIR;AAFA;AADA;AACA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAcA,kCAAkC;AAClC,MAAM,gBAAgB;IACpB,kBAAkB;IAClB,mBAAmB;IACnB,YAAY;AACd;AAEA,wBAAwB;AACxB,MAAM,YAAY;AAClB,MAAM,iBAAiB;AAEvB,6EAA6E;AAC7E,MAAM,0BACJ;AAEF,4CAA4C;AAC5C,IAAI,sBAAyC;AAC7C,IAAI,iBAAgC;AACpC,IAAI,mBAAkC;AACtC,IAAI,eAA8B;AAClC,IAAI,gBAA+B;AAQ5B,eAAe;IACpB,qDAAqD;IACrD,MAAM,aAAa,CAAA,GAAA,+JAAA,CAAA,sBAAmB,AAAD,EAAE;IACvC,gBAAgB,WAAW,OAAO;IAElC,4BAA4B;IAC5B,MAAM,UAAU;IAChB,sBAAsB,CAAA,GAAA,sLAAA,CAAA,wBAAqB,AAAD,EAAE;IAC5C,MAAM,qBAAqB,CAAA,GAAA,sLAAA,CAAA,kBAAe,AAAD,EAAE,qBAAqB;IAChE,iBAAiB,CAAA,GAAA,0KAAA,CAAA,KAAM,AAAD;IAEtB,0EAA0E;IAC1E,mDAAmD;IACnD,MAAM,WAAW,IAAI,sLAAA,CAAA,cAAW,CAAC,gBAAgB,oBAAoB,SAAS,KAAK;IAEnF,mBAAmB;IACnB,MAAM,UAAU,IAAI,sLAAA,CAAA,UAAO,CAAC,eAAe;QACzC,MAAM,aAAY,GAAwB;YACxC,uBAAuB;YACvB,OAAO,WAAW,WAAW,CAAC;gBAAE,SAAS;YAAI;QAC/C;IACF,GAAG;QAAE;IAAS;IAEd,2CAA2C;IAC3C,MAAM,uBAAuB,IAAI,sLAAA,CAAA,8BAA2B,CAAC;QAC3D,kBAAkB,cAAc,gBAAgB;QAChD,mBAAmB,cAAc,iBAAiB;QAClD,YAAY,cAAc,UAAU;IACtC;IAEA,2CAA2C;IAC3C,MAAM,mBAAmB,IAAI,sLAAA,CAAA,gBAAa,CACxC,sBACA,WACA,gBACA;IAGF,oBAAoB;IACpB,MAAM,iBAAiB,MAAM,iBAAiB,WAAW,CAAC;QAAC;KAAQ;IACnE,MAAM,CAAC,WAAW,GAAG;IAErB,+EAA+E;IAC/E,WAAW,KAAK,GAAG,OAAO,WAAW,KAAK;IAE1C,gDAAgD;IAChD,mBAAmB,WAAW,SAAS;IACvC,eAAe,WAAW,KAAK;AACjC;AAOO,eAAe;IAKpB,IAAI,CAAC,uBAAuB,CAAC,gBAAgB;QAC3C,MAAM,IAAI,MAAM;IAClB;IACA,IAAI,CAAC,oBAAoB,CAAC,cAAc;QACtC,MAAM,IAAI,MAAM;IAClB;IAEA,uBAAuB;IACvB,MAAM,UAAU,IAAI,sLAAA,CAAA,UAAO,CAAC,gBAAgB,qBAAqB;IAEjE,MAAM,uBAAuB,IAAI,sLAAA,CAAA,8BAA2B,CAAC;QAC3D,kBAAkB,cAAc,gBAAgB;QAChD,mBAAmB,cAAc,iBAAiB;QAClD,YAAY,cAAc,UAAU;IACtC;IAEA,MAAM,gBAAgB,IAAI,sLAAA,CAAA,gBAAa,CACrC,sBACA,WACA,gBACA;IAGF,OAAO;QACL;QACA,OAAO;QACP,WAAW;IACb;AACF;AAOO,SAAS,kBACd,aAA4B,EAC5B,KAAa,EACb,SAAiB,EACjB,UAAkB,WAAW;IAE7B,MAAM,eAAe,CAAC,EAAE,EAAE,WAAW;IACrC,MAAM,UAAU,CAAA,GAAA,uKAAA,CAAA,qBAAkB,AAAD,EAAE;IAEnC,QAAQ,GAAG,CAAC,gBAAgB;IAE5B,OAAO,CAAA,GAAA,qJAAA,CAAA,YAAS,AAAD,EAAE;QACf;QACA;QAEA,MAAM,aAAY,EAAE,OAAO,EAAE;YAC3B,4BAA4B;YAC5B,IAAI,mBACF,OAAO,YAAY,WACf,CAAA,GAAA,0JAAA,CAAA,cAAW,AAAD,EAAE,WACZ,CAAA,GAAA,0JAAA,CAAA,aAAU,AAAD,EAAE,QAAQ,GAAG;YAE5B,yBAAyB;YACzB,IAAI,iBAAiB,UAAU,CAAC,OAAO;gBACrC,mBAAmB,iBAAiB,KAAK,CAAC;YAC5C;YAEA,4CAA4C;YAC5C,MAAM,SAAS,iBAAiB,MAAM,KAAK;YAE3C,2EAA2E;YAC3E,MAAM,eAAe,SACjB,mBACA,CAAA,GAAA,uKAAA,CAAA,oBAAiB,AAAD,EAAE,kBAAkB,KAAK,CAAC;YAE9C,yCAAyC;YACzC,MAAM,cAAc,IAAI,sLAAA,CAAA,qBAAkB,GACvC,UAAU,CAAC,CAAA,GAAA,0KAAA,CAAA,KAAM,AAAD,KAAK,cAAc,YACnC,KAAK;YAER,mCAAmC;YACnC,MAAM,CAAC,KAAK,GAAG,MAAM,cAAc,WAAW,CAAC,OAAO,SAAS;YAE/D,kCAAkC;YAClC,MAAM,kBAAkB,CAAA,GAAA,oKAAA,CAAA,iBAAc,AAAD,EAAE;gBACrC,MAAM,CAAA,GAAA,iKAAA,CAAA,cAAW,AAAD,EAAE;gBAClB,WAAW,CAAA,GAAA,wKAAA,CAAA,qBAAkB,AAAD,EAAE,eAAe;YAC/C;YACA,IAAI,oBAAoB,SAAS;gBAC/B,MAAM,IAAI,MAAM;YAClB;YACA,OAAO,CAAA,GAAA,wKAAA,CAAA,qBAAkB,AAAD,EAAE,eAAe;QAC3C;QAEA,MAAM,iBAAgB,WAAW,EAAE,IAAI;YACrC,MAAM,aAAa,MAAM,cAAc,4KAAA,CAAA,uBAAoB;YAC3D,MAAM,sBACJ,YAAY,IAAI,KAAK,YACjB;gBAAE,GAAG,WAAW;gBAAE,UAAU;YAAM,IAClC;YAEN,uCAAuC;YACvC,MAAM,cAAc,IAAI,sLAAA,CAAA,qBAAkB,GACvC,UAAU,CACT,SACA,CAAA,GAAA,0JAAA,CAAA,YAAS,AAAD,EAAE,WAAW,uBACrB,UAED,KAAK;YAER,MAAM,CAAC,KAAK,GAAG,MAAM,cAAc,WAAW,CAAC,OAAO,SAAS;YAC/D,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;YAE3B,MAAM,YAAY,eAAe;YACjC,OAAO,WAAW,aAAa;QACjC;QAEA,MAAM,eAAc,SAAS;YAC3B,MAAM,cAAc,IAAI,sLAAA,CAAA,qBAAkB,GACvC,UAAU,CAAC,SAAS,CAAA,GAAA,mKAAA,CAAA,gBAAa,AAAD,EAAE,YAAY,UAC9C,KAAK;YAER,MAAM,CAAC,KAAK,GAAG,MAAM,cAAc,WAAW,CAAC,OAAO,SAAS;YAC/D,IAAI,CAAC,MAAM;gBACT,MAAM,IAAI,MAAM;YAClB;YAEA,MAAM,YAAY,eAAe;YACjC,OAAO,CAAA,GAAA,wKAAA,CAAA,qBAAkB,AAAD,EAAE;QAC5B;IACF;AACF;AAEA;;;CAGC,GACD,SAAS,eAAe,QAAsB;IAC5C,MAAM,SAAS,SAAS,IAAI,CAAC,UAAU,CAAC,QACpC,SAAS,IAAI,CAAC,KAAK,CAAC,KACpB,SAAS,IAAI;IAEjB,MAAM,IAAI,OAAO,OAAO,KAAK,CAAC,GAAG;IACjC,MAAM,IAAI,OAAO,OAAO,KAAK,CAAC,IAAI;IAClC,MAAM,QAAQ,SAAS,KAAK;IAE5B,OAAO;QACL;QACA;QACA,GAAG,OAAO;QACV,SAAS;IACX;AACF"}},
    {"offset": {"line": 205, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/src/app/page.tsx"],"sourcesContent":["// app/page.tsx\n\"use client\";\nimport { useState } from 'react';\nimport {\n  createSmartAccountClient,\n  toNexusAccount,\n  smartSessionCreateActions,\n  toSmartSessionsValidator,\n  smartSessionUseActions,\n  stringify,\n  parse,\n  SmartSessionMode,\n  CreateSessionDataParams,\n} from \"@biconomy/abstractjs\";\nimport { baseSepolia } from \"viem/chains\";\nimport { http, encodeFunctionData, Abi } from \"viem\";\nimport { createViemAccount, generateCryptographicKey, createSignerForSign } from '../../lib/sl';\nimport abi from './../../contracts/ABI.json';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { ethers } from 'ethers';\n\n\n\nconst CounterAbi = [\n\t{\n\t\t\"anonymous\": false,\n\t\t\"inputs\": [\n\t\t\t{\n\t\t\t\t\"indexed\": false,\n\t\t\t\t\"internalType\": \"uint256\",\n\t\t\t\t\"name\": \"newCounter\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t}\n\t\t],\n\t\t\"name\": \"Incremented\",\n\t\t\"type\": \"event\"\n\t},\n\t{\n\t\t\"inputs\": [],\n\t\t\"name\": \"counter\",\n\t\t\"outputs\": [\n\t\t\t{\n\t\t\t\t\"internalType\": \"uint256\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t}\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t},\n\t{\n\t\t\"inputs\": [],\n\t\t\"name\": \"increment\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t}\n] as const satisfies Abi;\n\nexport default function SessionPage() {\n  const [mpcSigner, setMpcSigner] = useState<any>(null);\n  const [sessionData, setSessionData] = useState<string | null>(null);\n  const [loading, setLoading] = useState<string>('');\n  const [txHash, setTxHash] = useState<string>('');\n\n  // Initialize MPC Signer: generate keys (if needed) and then create the signer for signing\n  const initializeMPCSigner = async () => {\n    setLoading('Initializing MPC signer...');\n    try {\n      // Generate key pair (this will store config in localStorage)\n      await generateCryptographicKey();\n      // Create a NetworkSigner using EphAuth for signing operations\n      const { networkSigner, keyId, publicKey } = await createSignerForSign();\n      const mpcAccount = createViemAccount(networkSigner, keyId, publicKey);\n      setMpcSigner(mpcAccount);\n      setLoading('');\n    } catch (error) {\n      console.error('MPC Signer Error:', error);\n      setLoading('');\n    }\n  };\n\n  // Create Biconomy Smart Session\n  const createSmartSession = async () => {\n    if (!mpcSigner) return;\n    setLoading('Creating smart session...');\n\n    try {\n      // Initialize Nexus client with owner account\n      const ownerPrivateKey = \"0x1439f4ea306e7a2ed953a1f7e948614c2b3a8d62ae034b50d9b4ba3f51124c03\"; // Replace with actual owner key\n      const ownerAccount = privateKeyToAccount(ownerPrivateKey);\n\n      const bundlerUrl = \"https://bundler.biconomy.io/api/v3/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44\";\n      const ownerAccountAddress = ownerAccount.address;\n      console.log(\"Owner Account:\", ownerAccountAddress);\n      const nexusClient = await createSmartAccountClient({\n        account: await toNexusAccount({\n          signer: ownerAccount,\n          chain: baseSepolia,\n          transport: http(),\n        }),\n        transport: http(bundlerUrl),\n      });\n      console.log(\"Nexus Client:\", nexusClient.account.address);\n\n      // Create and install sessions module\n      const sessionsModule = toSmartSessionsValidator({\n        account: nexusClient.account,\n        signer: ownerAccount\n      });\n      console.log(\"Sessions Module:\", sessionsModule.moduleInitData);\n\n      const hash = await nexusClient.installModule({\n        module: sessionsModule.moduleInitData\n      });\n      console.log(\"Module Installation Hash:\", hash);\n\n      \n    const { success: installSuccess } = await nexusClient.waitForUserOperationReceipt({ hash });\n\n    if (!installSuccess) {\n        console.error(\"❌ Failed to install Smart Sessions module\");\n        return;\n    }\n\n    console.log(\"✅ Smart Sessions module installed successfully\");\n\n      const nexusSessionClient = nexusClient.extend(smartSessionCreateActions(sessionsModule));\n\n      // Create session with MPC public key\n      // In createSmartSession()\n      const sessionRequestedInfo: CreateSessionDataParams[] = [\n        {\n          sessionPublicKey: mpcSigner.address as `0x${string}`, \n          actionPoliciesInfo: [{\n            contractAddress: \"0x7961d826258946969fa0d80b34508094c6148bdf\" as `0x${string}`,\n            abi : CounterAbi,\n            sudo: true \n          }]\n        }\n      ];\n      console.log(\"sessionRequestedInfo:\", sessionRequestedInfo);\n      console.log(\"MPC Session Public Key:\", mpcSigner.address);\n      console.log(\"Session Public Key in Policy:\", sessionRequestedInfo[0].sessionPublicKey);\n\n      const createSessionsResponse = await nexusSessionClient.grantPermission({\n        sessionRequestedInfo\n      });\n      const { success } = await nexusClient.waitForUserOperationReceipt({\n        hash: createSessionsResponse.userOpHash\n    });\n\n    if (!success) {\n        console.error(\"❌ Failed to create Smart Session\");\n        return;\n    }\n\n    console.log(\"✅ Smart Session created successfully\");\n\n      // Store session data in localStorage for persistence\n      const sessionData = {\n        granter: nexusClient.account.address,\n        sessionPublicKey: mpcSigner.address,\n        moduleData: {\n          permissionIds: createSessionsResponse.permissionIds, // ✅ Ensure these are included\n          action: createSessionsResponse.action,\n          mode: SmartSessionMode.USE,\n          sessions: createSessionsResponse.sessions\n        }\n      };\n\n      const compressedData = stringify(sessionData);\n      localStorage.setItem('mpcSessionData', compressedData);\n      setSessionData(compressedData);\n      setLoading('');\n    } catch (error) {\n      console.error('Session Creation Error:', error);\n      setLoading('');\n    }\n  };\n\n  // Execute Transaction with MPC Session\n  const executeTransaction = async () => {\n    if (!sessionData) return;\n    setLoading('Executing transaction...');\n\n    try {\n      const parsedData = parse(sessionData);\n      const bundlerUrl = \"https://bundler.biconomy.io/api/v3/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44\";\n\n      // Create MPC-powered client\n      console.log(\"Creating MPC-powered client...\");\n      const smartSessionClient = createSmartAccountClient({\n        chain: baseSepolia,\n        account: await toNexusAccount({\n          accountAddress: parsedData.granter,\n          signer: mpcSigner,\n          chain: baseSepolia,\n          transport: http(),\n        }),\n        transport: http(bundlerUrl)\n      });\n\n      // Attach sessions module\n      console.log(\"Attaching sessions module...\");\n      const usePermissionsModule = toSmartSessionsValidator({\n        account: smartSessionClient.account,\n        signer: mpcSigner,\n        moduleData: parsedData.moduleData\n      });\n\n      const sessionEnabledClient = smartSessionClient.extend(\n        smartSessionUseActions(usePermissionsModule)\n      );\n\n      // Execute transaction (example: calling 'increment')\n      console.log(\"Executing transaction...\");\n      const userOpHash = await sessionEnabledClient.usePermission({\n        calls: [{\n          to: \"0x7961d826258946969fa0d80b34508094c6148bdf\",\n          data: encodeFunctionData({\n            abi: CounterAbi,\n            functionName: \"increment\"\n          })\n        }]\n\n      });\n\n      setTxHash(userOpHash);\n      setLoading('');\n    } catch (error) {\n      console.error('Execution Error:', error);\n      setLoading('');\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen p-8\">\n      <h1 className=\"text-3xl mb-8\">MPC-Powered Smart Sessions</h1>\n\n      <div className=\"space-y-4 max-w-2xl\">\n        <button\n          onClick={initializeMPCSigner}\n          className=\"btn-primary\"\n          disabled={!!mpcSigner}\n        >\n          {mpcSigner ? 'MPC Signer Ready' : 'Initialize MPC Signer'}\n        </button>\n\n        {mpcSigner && (\n          <button\n            onClick={createSmartSession}\n            className=\"btn-secondary\"\n            disabled={!!sessionData}\n          >\n            {sessionData ? 'Session Created' : 'Create Smart Session'}\n          </button>\n        )}\n\n        {sessionData && (\n          <button\n            onClick={executeTransaction}\n            className=\"btn-success\"\n          >\n            Execute Transaction\n          </button>\n        )}\n\n        {loading && <p className=\"text-blue-500\">{loading}</p>}\n        {txHash && (\n          <div className=\"mt-4 p-4 bg-gray-100 rounded\">\n            <p className=\"font-mono break-words\">Transaction Hash: {txHash}</p>\n          </div>\n        )}\n\n        <div className=\"mt-8 space-y-2\">\n          {mpcSigner && (\n            <p>MPC Signer Address: {mpcSigner.address}</p>\n          )}\n          {sessionData && (\n            <p>Session Granter: {parse(sessionData).granter}</p>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AAEf;AAcA;AAEA;AAfA;AAAA;AAWA;AACA;AAZA;AAAA;AAAA;AAAA;AAYA;AAdA;;;;;;;;AAsBA,MAAM,aAAa;IAClB;QACC,aAAa;QACb,UAAU;YACT;gBACC,WAAW;gBACX,gBAAgB;gBAChB,QAAQ;gBACR,QAAQ;YACT;SACA;QACD,QAAQ;QACR,QAAQ;IACT;IACA;QACC,UAAU,EAAE;QACZ,QAAQ;QACR,WAAW;YACV;gBACC,gBAAgB;gBAChB,QAAQ;gBACR,QAAQ;YACT;SACA;QACD,mBAAmB;QACnB,QAAQ;IACT;IACA;QACC,UAAU,EAAE;QACZ,QAAQ;QACR,WAAW,EAAE;QACb,mBAAmB;QACnB,QAAQ;IACT;CACA;AAEc,SAAS;IACtB,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAO;IAChD,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAC9D,MAAM,CAAC,SAAS,WAAW,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAU;IAC/C,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAU;IAE7C,0FAA0F;IAC1F,MAAM,sBAAsB;QAC1B,WAAW;QACX,IAAI;YACF,6DAA6D;YAC7D,MAAM,CAAA,GAAA,yGAAA,CAAA,2BAAwB,AAAD;YAC7B,8DAA8D;YAC9D,MAAM,EAAE,aAAa,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,MAAM,CAAA,GAAA,yGAAA,CAAA,sBAAmB,AAAD;YACpE,MAAM,aAAa,CAAA,GAAA,yGAAA,CAAA,oBAAiB,AAAD,EAAE,eAAe,OAAO;YAC3D,aAAa;YACb,WAAW;QACb,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,qBAAqB;YACnC,WAAW;QACb;IACF;IAEA,gCAAgC;IAChC,MAAM,qBAAqB;QACzB,IAAI,CAAC,WAAW;QAChB,WAAW;QAEX,IAAI;YACF,6CAA6C;YAC7C,MAAM,kBAAkB,sEAAsE,gCAAgC;YAC9H,MAAM,eAAe,CAAA,GAAA,+JAAA,CAAA,sBAAmB,AAAD,EAAE;YAEzC,MAAM,aAAa;YACnB,MAAM,sBAAsB,aAAa,OAAO;YAChD,QAAQ,GAAG,CAAC,kBAAkB;YAC9B,MAAM,cAAc,MAAM,CAAA,GAAA,8LAAA,CAAA,2BAAwB,AAAD,EAAE;gBACjD,SAAS,MAAM,CAAA,GAAA,qLAAA,CAAA,iBAAc,AAAD,EAAE;oBAC5B,QAAQ;oBACR,OAAO,oKAAA,CAAA,cAAW;oBAClB,WAAW,CAAA,GAAA,6JAAA,CAAA,OAAI,AAAD;gBAChB;gBACA,WAAW,CAAA,GAAA,6JAAA,CAAA,OAAI,AAAD,EAAE;YAClB;YACA,QAAQ,GAAG,CAAC,iBAAiB,YAAY,OAAO,CAAC,OAAO;YAExD,qCAAqC;YACrC,MAAM,iBAAiB,CAAA,GAAA,yNAAA,CAAA,2BAAwB,AAAD,EAAE;gBAC9C,SAAS,YAAY,OAAO;gBAC5B,QAAQ;YACV;YACA,QAAQ,GAAG,CAAC,oBAAoB,eAAe,cAAc;YAE7D,MAAM,OAAO,MAAM,YAAY,aAAa,CAAC;gBAC3C,QAAQ,eAAe,cAAc;YACvC;YACA,QAAQ,GAAG,CAAC,6BAA6B;YAG3C,MAAM,EAAE,SAAS,cAAc,EAAE,GAAG,MAAM,YAAY,2BAA2B,CAAC;gBAAE;YAAK;YAEzF,IAAI,CAAC,gBAAgB;gBACjB,QAAQ,KAAK,CAAC;gBACd;YACJ;YAEA,QAAQ,GAAG,CAAC;YAEV,MAAM,qBAAqB,YAAY,MAAM,CAAC,CAAA,GAAA,oOAAA,CAAA,4BAAyB,AAAD,EAAE;YAExE,qCAAqC;YACrC,0BAA0B;YAC1B,MAAM,uBAAkD;gBACtD;oBACE,kBAAkB,UAAU,OAAO;oBACnC,oBAAoB;wBAAC;4BACnB,iBAAiB;4BACjB,KAAM;4BACN,MAAM;wBACR;qBAAE;gBACJ;aACD;YACD,QAAQ,GAAG,CAAC,yBAAyB;YACrC,QAAQ,GAAG,CAAC,2BAA2B,UAAU,OAAO;YACxD,QAAQ,GAAG,CAAC,iCAAiC,oBAAoB,CAAC,EAAE,CAAC,gBAAgB;YAErF,MAAM,yBAAyB,MAAM,mBAAmB,eAAe,CAAC;gBACtE;YACF;YACA,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,YAAY,2BAA2B,CAAC;gBAChE,MAAM,uBAAuB,UAAU;YAC3C;YAEA,IAAI,CAAC,SAAS;gBACV,QAAQ,KAAK,CAAC;gBACd;YACJ;YAEA,QAAQ,GAAG,CAAC;YAEV,qDAAqD;YACrD,MAAM,cAAc;gBAClB,SAAS,YAAY,OAAO,CAAC,OAAO;gBACpC,kBAAkB,UAAU,OAAO;gBACnC,YAAY;oBACV,eAAe,uBAAuB,aAAa;oBACnD,QAAQ,uBAAuB,MAAM;oBACrC,MAAM,6LAAA,CAAA,mBAAgB,CAAC,GAAG;oBAC1B,UAAU,uBAAuB,QAAQ;gBAC3C;YACF;YAEA,MAAM,iBAAiB,CAAA,GAAA,wMAAA,CAAA,YAAS,AAAD,EAAE;YACjC,aAAa,OAAO,CAAC,kBAAkB;YACvC,eAAe;YACf,WAAW;QACb,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;YACzC,WAAW;QACb;IACF;IAEA,uCAAuC;IACvC,MAAM,qBAAqB;QACzB,IAAI,CAAC,aAAa;QAClB,WAAW;QAEX,IAAI;YACF,MAAM,aAAa,CAAA,GAAA,wMAAA,CAAA,QAAK,AAAD,EAAE;YACzB,MAAM,aAAa;YAEnB,4BAA4B;YAC5B,QAAQ,GAAG,CAAC;YACZ,MAAM,qBAAqB,CAAA,GAAA,8LAAA,CAAA,2BAAwB,AAAD,EAAE;gBAClD,OAAO,oKAAA,CAAA,cAAW;gBAClB,SAAS,MAAM,CAAA,GAAA,qLAAA,CAAA,iBAAc,AAAD,EAAE;oBAC5B,gBAAgB,WAAW,OAAO;oBAClC,QAAQ;oBACR,OAAO,oKAAA,CAAA,cAAW;oBAClB,WAAW,CAAA,GAAA,6JAAA,CAAA,OAAI,AAAD;gBAChB;gBACA,WAAW,CAAA,GAAA,6JAAA,CAAA,OAAI,AAAD,EAAE;YAClB;YAEA,yBAAyB;YACzB,QAAQ,GAAG,CAAC;YACZ,MAAM,uBAAuB,CAAA,GAAA,yNAAA,CAAA,2BAAwB,AAAD,EAAE;gBACpD,SAAS,mBAAmB,OAAO;gBACnC,QAAQ;gBACR,YAAY,WAAW,UAAU;YACnC;YAEA,MAAM,uBAAuB,mBAAmB,MAAM,CACpD,CAAA,GAAA,oOAAA,CAAA,yBAAsB,AAAD,EAAE;YAGzB,qDAAqD;YACrD,QAAQ,GAAG,CAAC;YACZ,MAAM,aAAa,MAAM,qBAAqB,aAAa,CAAC;gBAC1D,OAAO;oBAAC;wBACN,IAAI;wBACJ,MAAM,CAAA,GAAA,kKAAA,CAAA,qBAAkB,AAAD,EAAE;4BACvB,KAAK;4BACL,cAAc;wBAChB;oBACF;iBAAE;YAEJ;YAEA,UAAU;YACV,WAAW;QACb,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,oBAAoB;YAClC,WAAW;QACb;IACF;IAEA,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC;gBAAG,WAAU;0BAAgB;;;;;;0BAE9B,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBACC,SAAS;wBACT,WAAU;wBACV,UAAU,CAAC,CAAC;kCAEX,YAAY,qBAAqB;;;;;;oBAGnC,2BACC,8OAAC;wBACC,SAAS;wBACT,WAAU;wBACV,UAAU,CAAC,CAAC;kCAEX,cAAc,oBAAoB;;;;;;oBAItC,6BACC,8OAAC;wBACC,SAAS;wBACT,WAAU;kCACX;;;;;;oBAKF,yBAAW,8OAAC;wBAAE,WAAU;kCAAiB;;;;;;oBACzC,wBACC,8OAAC;wBAAI,WAAU;kCACb,cAAA,8OAAC;4BAAE,WAAU;;gCAAwB;gCAAmB;;;;;;;;;;;;kCAI5D,8OAAC;wBAAI,WAAU;;4BACZ,2BACC,8OAAC;;oCAAE;oCAAqB,UAAU,OAAO;;;;;;;4BAE1C,6BACC,8OAAC;;oCAAE;oCAAkB,CAAA,GAAA,wMAAA,CAAA,QAAK,AAAD,EAAE,aAAa,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;AAM3D"}},
    {"offset": {"line": 537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}