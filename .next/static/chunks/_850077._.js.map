{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 12, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/browserWallet.ts"],"sourcesContent":["// lib/browserWallet.ts\nimport { TypedData, IBrowserWallet } from '@silencelaboratories/walletprovider-sdk';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { hashTypedData, hexToBytes, serializeSignature } from 'viem';\nimport { toHex } from 'viem/utils';\nimport { Buffer } from 'buffer';\n\nexport class BrowserWallet implements IBrowserWallet {\n  private privateKey: Uint8Array;\n\n  constructor(privateKeyHex: string) {\n    this.privateKey = Uint8Array.from(Buffer.from(privateKeyHex.replace(/^0x/, ''), 'hex'));\n  }\n\n  async signTypedData<T>(from: string, request: TypedData<T>): Promise<unknown> {\n    const castedRequest = {\n      ...request,\n      message: request.message as Record<string, unknown>,\n    };\n\n    // Create a hash of the typed data.\n    const messageHash = hashTypedData(castedRequest);\n    const messageBytes = hexToBytes(messageHash);\n\n    // Sign the hash.\n    const signature = secp256k1.sign(messageBytes, this.privateKey);\n\n    return serializeSignature({\n      r: toHex(signature.r),\n      s: toHex(signature.s),\n      v: BigInt(signature.recovery) + BigInt(27),\n    });\n  }\n}\n"],"names":[],"mappings":"AAAA,uBAAuB;;;;AAKvB;AAFA;AAAA;AADA;AACA;AACA;;;;;AAGO,MAAM;IACH,WAAuB;IAE/B,YAAY,aAAqB,CAAE;QACjC,IAAI,CAAC,UAAU,GAAG,WAAW,IAAI,CAAC,8JAAA,CAAA,SAAM,CAAC,IAAI,CAAC,cAAc,OAAO,CAAC,OAAO,KAAK;IAClF;IAEA,MAAM,cAAiB,IAAY,EAAE,OAAqB,EAAoB;QAC5E,MAAM,gBAAgB;YACpB,GAAG,OAAO;YACV,SAAS,QAAQ,OAAO;QAC1B;QAEA,mCAAmC;QACnC,MAAM,cAAc,CAAA,GAAA,sKAAA,CAAA,gBAAa,AAAD,EAAE;QAClC,MAAM,eAAe,CAAA,GAAA,+JAAA,CAAA,aAAU,AAAD,EAAE;QAEhC,iBAAiB;QACjB,MAAM,YAAY,wJAAA,CAAA,YAAS,CAAC,IAAI,CAAC,cAAc,IAAI,CAAC,UAAU;QAE9D,OAAO,CAAA,GAAA,2KAAA,CAAA,qBAAkB,AAAD,EAAE;YACxB,GAAG,CAAA,GAAA,6JAAA,CAAA,QAAK,AAAD,EAAE,UAAU,CAAC;YACpB,GAAG,CAAA,GAAA,6JAAA,CAAA,QAAK,AAAD,EAAE,UAAU,CAAC;YACpB,GAAG,OAAO,UAAU,QAAQ,IAAI,OAAO;QACzC;IACF;AACF"}},
    {"offset": {"line": 51, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/sl.ts"],"sourcesContent":["// lib/silenceLabs.ts\nimport { v4 as uuidv4 } from \"uuid\";\nimport { LocalAccount, privateKeyToAccount, toAccount, publicKeyToAddress } from 'viem/accounts';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport {\n  WalletProviderServiceClient,\n  EOAAuth,\n  EphKeyClaim,\n  generateEphPrivateKey,\n  getEphPublicKey,\n  NetworkSigner,\n  SignRequestBuilder,\n  EphAuth,\n  computeAddress,\n  SignResponse,\n} from \"@silencelaboratories/walletprovider-sdk\";\nimport { BrowserWallet } from \"./browserWallet\";\nimport { bytesToHex, stringToHex, toHex, keccak256, serializeSignature, serializeTransaction, hashTypedData, Signature, Hex } from \"viem\";\nimport { Base64 } from \"js-base64\";\n\n// Cluster configuration\nconst clusterConfig = {\n  walletProviderId: \"WalletProvider\",\n  walletProviderUrl: \"ws://34.118.117.249\", // update if needed\n  apiVersion: \"v1\",\n};\n\nconst THRESHOLD = 2;\nconst PARTIES_NUMBER = 3;\n\n// Key configuration interface\nexport interface KeyConfiguration {\n  publicKey: string;\n  keyId: string;\n  ephemeralKeyId: string;\n  // Store the ephemeral private key as a hex string (without 0x)\n  ephemeralPrivateKey: string;\n  signerAddress: string;\n  t: number;\n  n: number;\n  sessionAddress: string;\n}\n\n// Save/load key config from browser storage\nexport const saveKeyConfig = (config: KeyConfiguration) => {\n  localStorage.setItem(\"keyConfig\", JSON.stringify(config));\n};\n\nexport const loadKeyConfig = (): KeyConfiguration | null => {\n  const raw = localStorage.getItem(\"keyConfig\");\n  return raw ? JSON.parse(raw) : null;\n};\n\n// Utility: convert hex string to Uint8Array\nfunction hexToBytes(hexString: string): Uint8Array {\n  if (hexString.startsWith(\"0x\")) hexString = hexString.slice(2);\n  const bytes = new Uint8Array(hexString.length / 2);\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = parseInt(hexString.substr(i * 2, 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * generateCryptographicKey\n * Uses an EOAAuth flow (with a BrowserWallet) to generate the key pair.\n * Also generates an ephemeral key and then saves the key configuration in localStorage.\n */\nexport async function generateCryptographicKey(): Promise<{ keyConfig: KeyConfiguration; eoaNetworkSigner: NetworkSigner }> {\n  // Use a demo wallet private key (in production, obtain securely)\n  const demoWalletPrivateKey = \"0x6b17d0ae446c070ce14b12990cc10f5fcf89d3410277abea6f00352535502393\";\n  const browserWallet = new BrowserWallet(demoWalletPrivateKey);\n  const account = privateKeyToAccount(demoWalletPrivateKey);\n  const ownerAddress = account.address;\n\n  // Generate an ephemeral key for later signing\n  const algSign = \"secp256k1\";\n  const ephemeralPrivateKey = generateEphPrivateKey(algSign);\n  const ephemeralPublicKey = getEphPublicKey(ephemeralPrivateKey, algSign);\n  const ephId = uuidv4();\n  const ephClaim = new EphKeyClaim(ephId, ephemeralPublicKey, algSign, 60 * 60);\n\n  // Create the EOAAuth instance for key generation using the EOA (BrowserWallet)\n  const eoaAuth = new EOAAuth(ownerAddress, browserWallet, { ephClaim });\n\n  const walletProviderClient = new WalletProviderServiceClient({\n    walletProviderId: clusterConfig.walletProviderId,\n    walletProviderUrl: clusterConfig.walletProviderUrl,\n    apiVersion: \"v1\",\n  });\n\n  // Create network signer (using EOAAuth) to call generateKey\n  const eoaNetworkSigner = new NetworkSigner(walletProviderClient, THRESHOLD, PARTIES_NUMBER, eoaAuth);\n  const signAlg = \"secp256k1\";\n  const keygenResponse = await eoaNetworkSigner.generateKey([signAlg]);\n  const [primaryKey] = keygenResponse;\n  primaryKey.keyId = String(primaryKey.keyId);\n\n  console.log(\"Silence Labs keygen response:\", keygenResponse);\n\n  // Build key configuration object\n  const keyConfig: KeyConfiguration = {\n    publicKey: primaryKey.publicKey,\n    keyId: primaryKey.keyId,\n    ephemeralKeyId: ephId,\n    ephemeralPrivateKey: Buffer.from(ephemeralPrivateKey).toString(\"hex\"),\n    signerAddress: ownerAddress,\n    t: THRESHOLD,\n    n: PARTIES_NUMBER,\n    sessionAddress: computeAddress(primaryKey.publicKey),\n  };\n\n  // Store configuration in browser storage\n  saveKeyConfig(keyConfig);\n\n  return { keyConfig, eoaNetworkSigner };\n}\n\n/**\n * createSignerForSign\n * Loads the key configuration from localStorage and creates a NetworkSigner using EphAuth\n * for signing operations.\n */\nexport async function createSignerForSign(): Promise<{ networkSigner: NetworkSigner; keyId: string; publicKey: string }> {\n  const config = loadKeyConfig();\n  if (!config) {\n    throw new Error(\"Key configuration not found. Please generate keys first.\");\n  }\n  const ephemeralPrivateKeyBytes = hexToBytes(config.ephemeralPrivateKey);\n  const ephAuth = new EphAuth(config.ephemeralKeyId, ephemeralPrivateKeyBytes, \"secp256k1\");\n\n  const walletProviderClient = new WalletProviderServiceClient({\n    walletProviderId: clusterConfig.walletProviderId,\n    walletProviderUrl: clusterConfig.walletProviderUrl,\n    apiVersion: \"v1\",\n  });\n\n  const networkSigner = new NetworkSigner(walletProviderClient, config.t, config.n, ephAuth);\n  return { networkSigner, keyId: config.keyId, publicKey: config.publicKey };\n}\n\n/**\n * createViemAccount\n * Creates a Viem-compatible account object from the given network signer.\n */\nexport function createViemAccount(\n  networkSigner: NetworkSigner,\n  keyId: string,\n  publicKey: string,\n  signAlg: string = 'secp256k1',\n): LocalAccount {\n  const publicKeyHex = `0x${publicKey}`;\n  const address = publicKeyToAddress(publicKeyHex as `0x${string}`);\n  console.log(\"Generated MPC Address:\", address);\n  return toAccount({\n    address,\n    keyId,\n    async signMessage({ message }) {\n      console.log(\"signMessage\", message);\n      message = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (typeof message.raw === \"string\") {\n          return message.raw;\n        }\n        return bytesToHex(message.raw);\n      })();\n      if (message.slice(0, 2) === \"0x\") {\n        message = message.slice(2);\n      }\n      console.log(\"Processed message:\", message);\n      const signRequest = new SignRequestBuilder()\n        .setRequest(uuidv4(), message, \"rawBytes\")\n        .build();\n      console.log(\"Sign Request:\", signRequest);\n      console.log(\"Using network signer:\", networkSigner);\n      const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n      console.log(\"Signature response:\", sign);\n      if (sign) {\n        const signature = formatViemSign(sign);\n        return serializeSignature(signature);\n      }\n      throw new Error('No signature returned from network');\n    },\n    async signTransaction(transaction, args) {\n      console.log(\"Sign Transaction\", transaction);\n      const serializer = args?.serializer || serializeTransaction;\n      const signableTransaction = (() => {\n        if (transaction.type === 'eip4844') {\n          return { ...transaction, sidecars: false };\n        }\n        return transaction;\n      })();\n      const signRequest = new SignRequestBuilder()\n        .setRequest(address, keccak256(serializer(signableTransaction)), 'EIP191')\n        .build();\n      const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n      if (sign) {\n        const signature = formatViemSign(sign);\n        return serializer(transaction, signature);\n      }\n      throw new Error('No signature returned from network');\n    },\n    async signTypedData(typedData) {\n      console.log(\"Sign Typed Data\", typedData);\n      const signRequest = new SignRequestBuilder()\n        .setRequest(address, hashTypedData(typedData), 'EIP712')\n        .build();\n      const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n      if (sign) {\n        const signature = formatViemSign(sign);\n        return serializeSignature(signature);\n      }\n      throw new Error('No signature returned from network');\n    },\n  });\n}\n\nfunction formatViemSign(signResp: SignResponse): Signature {\n  const sign =  signResp.sign\n  const hexSig = sign.startsWith(\"0x\") ? sign.slice(2) : sign;\n  const r = \"0x\" + hexSig.slice(0, 64) as Hex; // first 64 hex characters = 32 bytes\n  const s = \"0x\" + hexSig.slice(64, 128) as Hex; // next 64 hex characters = 32 bytes\n  const recid = signResp.recid;\n  const signature = {\n    r,\n    s,\n    v: recid === 0 ? BigInt(27) : BigInt(28),\n    yParity: recid,\n  };\n  return signature;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 255, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/src/app/page.tsx"],"sourcesContent":["// // app/page.tsx\n\"use client\";\n// import { useState } from 'react';\n// import {\n//   createSmartAccountClient,\n//   toNexusAccount,\n//   smartSessionCreateActions,\n//   toSmartSessionsValidator,\n//   smartSessionUseActions,\n//   stringify,\n//   parse,\n//   SmartSessionMode,\n//   CreateSessionDataParams,\n// } from \"@biconomy/abstractjs\";\n// import { baseSepolia } from \"viem/chains\";\n// import { http, encodeFunctionData } from \"viem\";\n// import { createViemAccount, generateCryptographicKey, createSignerForSign } from '../../lib/sl';\nimport abi from './../../contracts/ABI.json';\n// import { privateKeyToAccount } from 'viem/accounts';\n// import { ethers } from 'ethers';\n\n// export default function SessionPage() {\n//   const [mpcSigner, setMpcSigner] = useState<any>(null);\n//   const [sessionData, setSessionData] = useState<string | null>(null);\n//   const [loading, setLoading] = useState<string>('');\n//   const [txHash, setTxHash] = useState<string>('');\n\n//   // Initialize MPC Signer: generate keys (if needed) and then create the signer for signing\n//   const initializeMPCSigner = async () => {\n//     setLoading('Initializing MPC signer...');\n//     try {\n//       // Generate key pair (this will store config in localStorage)\n//       await generateCryptographicKey();\n//       // Create a NetworkSigner using EphAuth for signing operations\n//       const { networkSigner, keyId, publicKey } = await createSignerForSign();\n//       const mpcAccount = createViemAccount(networkSigner, keyId, publicKey);\n//       setMpcSigner(mpcAccount);\n//       setLoading('');\n//     } catch (error) {\n//       console.error('MPC Signer Error:', error);\n//       setLoading('');\n//     }\n//   };\n\n//   // Create Biconomy Smart Session\n//   const createSmartSession = async () => {\n//     if (!mpcSigner) return;\n//     setLoading('Creating smart session...');\n\n//     try {\n//       // Initialize Nexus client with owner account\n//       const ownerPrivateKey = \"0xec2387b319f9c96c5f2a3f9f5152208d09c0265d139235cab9c90511e6836fc7\"; // Replace with actual owner key\n//       const ownerAccount = privateKeyToAccount(ownerPrivateKey);\n\n//       const bundlerUrl = \"https://bundler.biconomy.io/api/v3/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44\";\n//       const ownerAccountAddress = ownerAccount.address;\n//       console.log(\"Owner Account:\", ownerAccountAddress);\n//       const nexusClient = await createSmartAccountClient({\n//         account: await toNexusAccount({\n//           signer: ownerAccount,\n//           chain: baseSepolia,\n//           transport: http(),\n//         }),\n//         transport: http(bundlerUrl),\n//       });\n//       console.log(\"Nexus Client:\", nexusClient.account.address);\n\n//       // Create and install sessions module\n//       const sessionsModule = toSmartSessionsValidator({\n//         account: nexusClient.account,\n//         signer: ownerAccount\n//       });\n//       console.log(\"Sessions Module:\", sessionsModule.moduleInitData);\n\n//       const hash = await nexusClient.installModule({\n//         module: sessionsModule.moduleInitData\n//       });\n//       console.log(\"Module Installation Hash:\", hash);\n\n//       await nexusClient.waitForUserOperationReceipt({ hash });\n\n//       const nexusSessionClient = nexusClient.extend(smartSessionCreateActions(sessionsModule));\n\n//       // Create session with MPC public key\n//       const sessionRequestedInfo: CreateSessionDataParams[] = [\n//         {\n//           sessionKeyData: mpcSigner.address as `0x${string}`,\n//           actionPoliciesInfo: [{\n//             contractAddress: \"0x7961d826258946969fa0d80b34508094c6148bdf\" as `0x${string}`,\n//             rules: [],\n//             functionSelector: \"0xd09de08a\" as `0x${string}` // Function selector for 'increment'\n//           }]\n//         }\n//       ];\n//       console.log(\"sessionRequestedInfo:\", sessionRequestedInfo);\n\n//       const createSessionsResponse = await nexusSessionClient.grantPermission({\n//         sessionRequestedInfo\n//       });\n\n//       await nexusClient.waitForUserOperationReceipt({\n//         hash: createSessionsResponse.userOpHash\n//       });\n\n//       // Store session data in localStorage for persistence\n//       const sessionDataObj = {\n//         granter: nexusClient.account.address,\n//         sessionPublicKey: mpcSigner.address,\n//         description: `MPC Session for ${nexusClient.account.address.slice(0, 6)}`,\n//         moduleData: {\n//           ...createSessionsResponse,\n//           mode: SmartSessionMode.USE\n//         }\n//       };\n\n//       const compressedData = stringify(sessionDataObj);\n//       localStorage.setItem('mpcSessionData', compressedData);\n//       setSessionData(compressedData);\n//       setLoading('');\n//     } catch (error) {\n//       console.error('Session Creation Error:', error);\n//       setLoading('');\n//     }\n//   };\n\n//   // Execute Transaction with MPC Session\n//   const executeTransaction = async () => {\n//     if (!sessionData) return;\n//     setLoading('Executing transaction...');\n\n//     try {\n//       const parsedData = parse(sessionData);\n//       const bundlerUrl = \"https://bundler.biconomy.io/api/v3/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44\";\n\n//       // Create MPC-powered client\n//       console.log(\"Creating MPC-powered client...\");\n//       const smartSessionClient = createSmartAccountClient({\n//         chain: baseSepolia,\n//         account: await toNexusAccount({\n//           signer: mpcSigner,\n//           chain: baseSepolia,\n//           transport: http(),\n//         }),\n//         transport: http(bundlerUrl)\n//       });\n\n//       // Attach sessions module\n//       console.log(\"Attaching sessions module...\");\n//       const usePermissionsModule = toSmartSessionsValidator({\n//         account: smartSessionClient.account,\n//         signer: mpcSigner,\n//         moduleData: parsedData.moduleData\n//       });\n\n//       const sessionEnabledClient = smartSessionClient.extend(\n//         smartSessionUseActions(usePermissionsModule)\n//       );\n\n//       // Execute transaction (example: calling 'increment')\n//       console.log(\"Executing transaction...\");\n//       const userOpHash = await sessionEnabledClient.usePermission({\n//         calls: [{\n//           to: \"0x7961d826258946969fa0d80b34508094c6148bdf\",\n//           data: encodeFunctionData({\n//             abi: abi,\n//             functionName: \"increment\"\n//           })\n//         }],\n//         callGasLimit: BigInt(100000),\n//         verificationGasLimit: BigInt(500000),\n//         preVerificationGas: BigInt(300000)\n\n//       });\n\n//       setTxHash(userOpHash);\n//       setLoading('');\n//     } catch (error) {\n//       console.error('Execution Error:', error);\n//       setLoading('');\n//     }\n//   };\n\n//   return (\n//     <div className=\"min-h-screen p-8\">\n//       <h1 className=\"text-3xl mb-8\">MPC-Powered Smart Sessions</h1>\n\n//       <div className=\"space-y-4 max-w-2xl\">\n//         <button\n//           onClick={initializeMPCSigner}\n//           className=\"btn-primary\"\n//           disabled={!!mpcSigner}\n//         >\n//           {mpcSigner ? 'MPC Signer Ready' : 'Initialize MPC Signer'}\n//         </button>\n\n//         {mpcSigner && (\n//           <button\n//             onClick={createSmartSession}\n//             className=\"btn-secondary\"\n//             disabled={!!sessionData}\n//           >\n//             {sessionData ? 'Session Created' : 'Create Smart Session'}\n//           </button>\n//         )}\n\n//         {sessionData && (\n//           <button\n//             onClick={executeTransaction}\n//             className=\"btn-success\"\n//           >\n//             Execute Transaction\n//           </button>\n//         )}\n\n//         {loading && <p className=\"text-blue-500\">{loading}</p>}\n//         {txHash && (\n//           <div className=\"mt-4 p-4 bg-gray-100 rounded\">\n//             <p className=\"font-mono break-words\">Transaction Hash: {txHash}</p>\n//           </div>\n//         )}\n\n//         <div className=\"mt-8 space-y-2\">\n//           {mpcSigner && (\n//             <p>MPC Signer Address: {mpcSigner.address}</p>\n//           )}\n//           {sessionData && (\n//             <p>Session Granter: {parse(sessionData).granter}</p>\n//           )}\n//         </div>\n//       </div>\n//     </div>\n//   );\n// }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 455, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}