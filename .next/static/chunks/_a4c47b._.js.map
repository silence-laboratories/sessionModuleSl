{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/browserWallet.ts"],"sourcesContent":["// lib/browserWallet.ts\nimport { TypedData, IBrowserWallet } from '@silencelaboratories/walletprovider-sdk';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { hashTypedData, hexToBytes, serializeSignature } from 'viem';\nimport { toHex } from 'viem/utils';\nimport { Buffer } from 'buffer';\n\nexport class BrowserWallet implements IBrowserWallet {\n  private privateKey: Uint8Array;\n\n  constructor(privateKeyHex: string) {\n    this.privateKey = Uint8Array.from(Buffer.from(privateKeyHex.replace(/^0x/, ''), 'hex'));\n  }\n\n  async signTypedData<T>(from: string, request: TypedData<T>): Promise<unknown> {\n    const castedRequest = {\n      ...request,\n      message: request.message as Record<string, unknown>,\n    };\n\n    // Create a hash of the typed data.\n    const messageHash = hashTypedData(castedRequest);\n    const messageBytes = hexToBytes(messageHash);\n\n    // Sign the hash.\n    const signature = secp256k1.sign(messageBytes, this.privateKey);\n\n    return serializeSignature({\n      r: toHex(signature.r),\n      s: toHex(signature.s),\n      v: BigInt(signature.recovery) + BigInt(27),\n    });\n  }\n}\n"],"names":[],"mappings":"AAAA,uBAAuB;;;;AAKvB;AAFA;AAAA;AADA;AACA;AACA;;;;;AAGO,MAAM;IACH,WAAuB;IAE/B,YAAY,aAAqB,CAAE;QACjC,IAAI,CAAC,UAAU,GAAG,WAAW,IAAI,CAAC,8JAAA,CAAA,SAAM,CAAC,IAAI,CAAC,cAAc,OAAO,CAAC,OAAO,KAAK;IAClF;IAEA,MAAM,cAAiB,IAAY,EAAE,OAAqB,EAAoB;QAC5E,MAAM,gBAAgB;YACpB,GAAG,OAAO;YACV,SAAS,QAAQ,OAAO;QAC1B;QAEA,mCAAmC;QACnC,MAAM,cAAc,CAAA,GAAA,sKAAA,CAAA,gBAAa,AAAD,EAAE;QAClC,MAAM,eAAe,CAAA,GAAA,+JAAA,CAAA,aAAU,AAAD,EAAE;QAEhC,iBAAiB;QACjB,MAAM,YAAY,wJAAA,CAAA,YAAS,CAAC,IAAI,CAAC,cAAc,IAAI,CAAC,UAAU;QAE9D,OAAO,CAAA,GAAA,2KAAA,CAAA,qBAAkB,AAAD,EAAE;YACxB,GAAG,CAAA,GAAA,6JAAA,CAAA,QAAK,AAAD,EAAE,UAAU,CAAC;YACpB,GAAG,CAAA,GAAA,6JAAA,CAAA,QAAK,AAAD,EAAE,UAAU,CAAC;YACpB,GAAG,OAAO,UAAU,QAAQ,IAAI,OAAO;QACzC;IACF;AACF"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/sl.ts"],"sourcesContent":["// lib/silenceLabs.ts\nimport { v4 as uuidv4 } from \"uuid\";\nimport { LocalAccount, privateKeyToAccount, toAccount, publicKeyToAddress } from 'viem/accounts';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport {\n  WalletProviderServiceClient,\n  EOAAuth,\n  EphKeyClaim,\n  generateEphPrivateKey,\n  getEphPublicKey,\n  NetworkSigner,\n  SignRequestBuilder,\n  EphAuth,\n  computeAddress,\n  SignResponse,\n} from \"@silencelaboratories/walletprovider-sdk\";\nimport { BrowserWallet } from \"./browserWallet\";\nimport { bytesToHex, stringToHex, toHex, keccak256, serializeSignature, serializeTransaction, hashTypedData, Signature, Hex } from \"viem\";\nimport { Base64 } from \"js-base64\";\n\n// Cluster configuration\nconst clusterConfig = {\n  walletProviderId: \"WalletProvider\",\n  walletProviderUrl: \"ws://34.118.117.249\", // update if needed\n  apiVersion: \"v1\",\n};\n\nconst THRESHOLD = 2;\nconst PARTIES_NUMBER = 3;\n\n// Key configuration interface\nexport interface KeyConfiguration {\n  publicKey: string;\n  keyId: string;\n  ephemeralKeyId: string;\n  // Store the ephemeral private key as a hex string (without 0x)\n  ephemeralPrivateKey: string;\n  signerAddress: string;\n  t: number;\n  n: number;\n  sessionAddress: string;\n}\n\n// Save/load key config from browser storage\nexport const saveKeyConfig = (config: KeyConfiguration) => {\n  localStorage.setItem(\"keyConfig\", JSON.stringify(config));\n};\n\nexport const loadKeyConfig = (): KeyConfiguration | null => {\n  const raw = localStorage.getItem(\"keyConfig\");\n  return raw ? JSON.parse(raw) : null;\n};\n\n// Utility: convert hex string to Uint8Array\nfunction hexToBytes(hexString: string): Uint8Array {\n  if (hexString.startsWith(\"0x\")) hexString = hexString.slice(2);\n  const bytes = new Uint8Array(hexString.length / 2);\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = parseInt(hexString.substr(i * 2, 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * generateCryptographicKey\n * Uses an EOAAuth flow (with a BrowserWallet) to generate the key pair.\n * Also generates an ephemeral key and then saves the key configuration in localStorage.\n */\nexport async function generateCryptographicKey(): Promise<{ keyConfig: KeyConfiguration; eoaNetworkSigner: NetworkSigner }> {\n  // Use a demo wallet private key (in production, obtain securely)\n  const demoWalletPrivateKey = \"0x6b17d0ae446c070ce14b12990cc10f5fcf89d3410277abea6f00352535502393\";\n  const browserWallet = new BrowserWallet(demoWalletPrivateKey);\n  const account = privateKeyToAccount(demoWalletPrivateKey);\n  const ownerAddress = account.address;\n\n  // Generate an ephemeral key for later signing\n  const algSign = \"secp256k1\";\n  const ephemeralPrivateKey = generateEphPrivateKey(algSign);\n  const ephemeralPublicKey = getEphPublicKey(ephemeralPrivateKey, algSign);\n  const ephId = uuidv4();\n  const ephClaim = new EphKeyClaim(ephId, ephemeralPublicKey, algSign, 60 * 60);\n\n  // Create the EOAAuth instance for key generation using the EOA (BrowserWallet)\n  const eoaAuth = new EOAAuth(ownerAddress, browserWallet, { ephClaim });\n\n  const walletProviderClient = new WalletProviderServiceClient({\n    walletProviderId: clusterConfig.walletProviderId,\n    walletProviderUrl: clusterConfig.walletProviderUrl,\n    apiVersion: \"v1\",\n  });\n\n  // Create network signer (using EOAAuth) to call generateKey\n  const eoaNetworkSigner = new NetworkSigner(walletProviderClient, THRESHOLD, PARTIES_NUMBER, eoaAuth);\n  const signAlg = \"secp256k1\";\n  const keygenResponse = await eoaNetworkSigner.generateKey([signAlg]);\n  const [primaryKey] = keygenResponse;\n  primaryKey.keyId = String(primaryKey.keyId);\n\n  console.log(\"Silence Labs keygen response:\", keygenResponse);\n\n  // Build key configuration object\n  const keyConfig: KeyConfiguration = {\n    publicKey: primaryKey.publicKey,\n    keyId: primaryKey.keyId,\n    ephemeralKeyId: ephId,\n    ephemeralPrivateKey: Buffer.from(ephemeralPrivateKey).toString(\"hex\"),\n    signerAddress: ownerAddress,\n    t: THRESHOLD,\n    n: PARTIES_NUMBER,\n    sessionAddress: computeAddress(primaryKey.publicKey),\n  };\n\n  // Store configuration in browser storage\n  saveKeyConfig(keyConfig);\n\n  return { keyConfig, eoaNetworkSigner };\n}\n\n/**\n * createSignerForSign\n * Loads the key configuration from localStorage and creates a NetworkSigner using EphAuth\n * for signing operations.\n */\nexport async function createSignerForSign(): Promise<{ networkSigner: NetworkSigner; keyId: string; publicKey: string }> {\n  const config = loadKeyConfig();\n  if (!config) {\n    throw new Error(\"Key configuration not found. Please generate keys first.\");\n  }\n  const ephemeralPrivateKeyBytes = hexToBytes(config.ephemeralPrivateKey);\n  const ephAuth = new EphAuth(config.ephemeralKeyId, ephemeralPrivateKeyBytes, \"secp256k1\");\n\n  const walletProviderClient = new WalletProviderServiceClient({\n    walletProviderId: clusterConfig.walletProviderId,\n    walletProviderUrl: clusterConfig.walletProviderUrl,\n    apiVersion: \"v1\",\n  });\n\n  const networkSigner = new NetworkSigner(walletProviderClient, config.t, config.n, ephAuth);\n  return { networkSigner, keyId: config.keyId, publicKey: config.publicKey };\n}\n\n/**\n * createViemAccount\n * Creates a Viem-compatible account object from the given network signer.\n */\nexport function createViemAccount(\n  networkSigner: NetworkSigner,\n  keyId: string,\n  publicKey: string,\n  signAlg: string = 'secp256k1',\n): LocalAccount {\n  const publicKeyHex = `0x${publicKey}`;\n  const address = publicKeyToAddress(publicKeyHex as `0x${string}`);\n  console.log(\"Generated MPC Address:\", address);\n  return toAccount({\n    address,\n    keyId,\n    async signMessage({ message }) {\n      console.log(\"signMessage\", message);\n      message = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (typeof message.raw === \"string\") {\n          return message.raw;\n        }\n        return bytesToHex(message.raw);\n      })();\n      if (message.slice(0, 2) === \"0x\") {\n        message = message.slice(2);\n      }\n      console.log(\"Processed message:\", message);\n      const signRequest = new SignRequestBuilder()\n        .setRequest(uuidv4(), message, \"EIP191\")  \n        .build();\n      console.log(\"Sign Request:\", signRequest);\n      console.log(\"Using network signer:\", networkSigner);\n      const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n      console.log(\"Signature response:\", sign);\n      if (sign) {\n        const signature = formatViemSign(sign);\n        return serializeSignature(signature);\n      }\n      throw new Error('No signature returned from network');\n    },\n    async signTransaction(transaction, args) {\n      console.log(\"Sign Transaction\", transaction);\n      const serializer = args?.serializer || serializeTransaction;\n      const signableTransaction = (() => {\n        if (transaction.type === 'eip4844') {\n          return { ...transaction, sidecars: false };\n        }\n        return transaction;\n      })();\n      const signRequest = new SignRequestBuilder()\n        .setRequest(address, keccak256(serializer(signableTransaction)), 'EIP191')\n        .build();\n      const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n      if (sign) {\n        const signature = formatViemSign(sign);\n        return serializer(transaction, signature);\n      }\n      throw new Error('No signature returned from network');\n    },\n    async signTypedData(typedData) {\n      console.log(\"Sign Typed Data\", typedData);\n      const signRequest = new SignRequestBuilder()\n        .setRequest(address, hashTypedData(typedData), 'EIP712')\n        .build();\n      const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n      if (sign) {\n        const signature = formatViemSign(sign);\n        return serializeSignature(signature);\n      }\n      throw new Error('No signature returned from network');\n    },\n  });\n}\n\nfunction formatViemSign(signResp: SignResponse): Signature {\n  const sign =  signResp.sign\n  const hexSig = sign.startsWith(\"0x\") ? sign.slice(2) : sign;\n  const r = \"0x\" + hexSig.slice(0, 64) as Hex; // first 64 hex characters = 32 bytes\n  const s = \"0x\" + hexSig.slice(64, 128) as Hex; // next 64 hex characters = 32 bytes\n  const recid = signResp.recid;\n  const signature = {\n    r,\n    s,\n    v: recid === 0 ? BigInt(27) : BigInt(28),\n    yParity: recid,\n  };\n  return signature;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 250, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/src/app/page.tsx"],"sourcesContent":["// app/page.tsx\n\"use client\";\nimport { useState } from 'react';\nimport {\n  createSmartAccountClient,\n  toNexusAccount,\n  smartSessionCreateActions,\n  toSmartSessionsValidator,\n  smartSessionUseActions,\n  stringify,\n  parse,\n  SmartSessionMode,\n  CreateSessionDataParams,\n} from \"@biconomy/abstractjs\";\nimport { baseSepolia } from \"viem/chains\";\nimport { http, encodeFunctionData } from \"viem\";\nimport { createViemAccount, generateCryptographicKey, createSignerForSign } from '../../lib/sl';\nimport abi from './../../contracts/ABI.json';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { ethers } from 'ethers';\n\nexport default function SessionPage() {\n  const [mpcSigner, setMpcSigner] = useState<any>(null);\n  const [sessionData, setSessionData] = useState<string | null>(null);\n  const [loading, setLoading] = useState<string>('');\n  const [txHash, setTxHash] = useState<string>('');\n\n  // Initialize MPC Signer: generate keys (if needed) and then create the signer for signing\n  const initializeMPCSigner = async () => {\n    setLoading('Initializing MPC signer...');\n    try {\n      // Generate key pair (this will store config in localStorage)\n      await generateCryptographicKey();\n      // Create a NetworkSigner using EphAuth for signing operations\n      const { networkSigner, keyId, publicKey } = await createSignerForSign();\n      const mpcAccount = createViemAccount(networkSigner, keyId, publicKey);\n      setMpcSigner(mpcAccount);\n      setLoading('');\n    } catch (error) {\n      console.error('MPC Signer Error:', error);\n      setLoading('');\n    }\n  };\n\n  // Create Biconomy Smart Session\n  const createSmartSession = async () => {\n    if (!mpcSigner) return;\n    setLoading('Creating smart session...');\n\n    try {\n      // Initialize Nexus client with owner account\n      const ownerPrivateKey = \"0xec2387b319f9c96c5f2a3f9f5152208d09c0265d139235cab9c90511e6836fc7\"; // Replace with actual owner key\n      const ownerAccount = privateKeyToAccount(ownerPrivateKey);\n\n      const bundlerUrl = \"https://bundler.biconomy.io/api/v3/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44\";\n      const ownerAccountAddress = ownerAccount.address;\n      console.log(\"Owner Account:\", ownerAccountAddress);\n      const nexusClient = await createSmartAccountClient({\n        account: await toNexusAccount({\n          signer: ownerAccount,\n          chain: baseSepolia,\n          transport: http(),\n        }),\n        transport: http(bundlerUrl),\n      });\n      console.log(\"Nexus Client:\", nexusClient.account.address);\n\n      // Create and install sessions module\n      const sessionsModule = toSmartSessionsValidator({\n        account: nexusClient.account,\n        signer: ownerAccount\n      });\n      console.log(\"Sessions Module:\", sessionsModule.moduleInitData);\n\n      const hash = await nexusClient.installModule({\n        module: sessionsModule.moduleInitData\n      });\n      console.log(\"Module Installation Hash:\", hash);\n\n      await nexusClient.waitForUserOperationReceipt({ hash });\n\n      const nexusSessionClient = nexusClient.extend(smartSessionCreateActions(sessionsModule));\n\n      // Create session with MPC public key\n      const sessionRequestedInfo: CreateSessionDataParams[] = [\n        {\n          sessionKeyData: mpcSigner.address as `0x${string}`,\n          actionPoliciesInfo: [{\n            contractAddress: \"0x7961d826258946969fa0d80b34508094c6148bdf\" as `0x${string}`,\n            rules: [],\n            functionSelector: \"0xd09de08a\" as `0x${string}` // Function selector for 'increment'\n          }]\n        }\n      ];\n      console.log(\"sessionRequestedInfo:\", sessionRequestedInfo);\n\n      const createSessionsResponse = await nexusSessionClient.grantPermission({\n        sessionRequestedInfo\n      });\n\n      await nexusClient.waitForUserOperationReceipt({\n        hash: createSessionsResponse.userOpHash\n      });\n\n      // Store session data in localStorage for persistence\n      const sessionDataObj = {\n        granter: nexusClient.account.address,\n        sessionPublicKey: mpcSigner.address,\n        description: `MPC Session for ${nexusClient.account.address.slice(0, 6)}`,\n        moduleData: {\n          ...createSessionsResponse,\n          mode: SmartSessionMode.USE\n        }\n      };\n\n      const compressedData = stringify(sessionDataObj);\n      localStorage.setItem('mpcSessionData', compressedData);\n      setSessionData(compressedData);\n      setLoading('');\n    } catch (error) {\n      console.error('Session Creation Error:', error);\n      setLoading('');\n    }\n  };\n\n  // Execute Transaction with MPC Session\n  const executeTransaction = async () => {\n    if (!sessionData) return;\n    setLoading('Executing transaction...');\n\n    try {\n      const parsedData = parse(sessionData);\n      const bundlerUrl = \"https://bundler.biconomy.io/api/v3/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44\";\n\n      // Create MPC-powered client\n      console.log(\"Creating MPC-powered client...\");\n      const smartSessionClient = createSmartAccountClient({\n        chain: baseSepolia,\n        account: await toNexusAccount({\n          signer: mpcSigner,\n          chain: baseSepolia,\n          transport: http(),\n        }),\n        transport: http(bundlerUrl)\n      });\n\n      // Attach sessions module\n      console.log(\"Attaching sessions module...\");\n      const usePermissionsModule = toSmartSessionsValidator({\n        account: smartSessionClient.account,\n        signer: mpcSigner,\n        moduleData: parsedData.moduleData\n      });\n\n      const sessionEnabledClient = smartSessionClient.extend(\n        smartSessionUseActions(usePermissionsModule)\n      );\n\n      // Execute transaction (example: calling 'increment')\n      console.log(\"Executing transaction...\");\n      const userOpHash = await sessionEnabledClient.usePermission({\n        calls: [{\n          to: \"0x7961d826258946969fa0d80b34508094c6148bdf\",\n          data: encodeFunctionData({\n            abi: abi,\n            functionName: \"increment\"\n          })\n        }],\n        callGasLimit: BigInt(100000),\n        verificationGasLimit: BigInt(500000),\n        preVerificationGas: BigInt(300000)\n\n      });\n\n      setTxHash(userOpHash);\n      setLoading('');\n    } catch (error) {\n      console.error('Execution Error:', error);\n      setLoading('');\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen p-8\">\n      <h1 className=\"text-3xl mb-8\">MPC-Powered Smart Sessions</h1>\n\n      <div className=\"space-y-4 max-w-2xl\">\n        <button\n          onClick={initializeMPCSigner}\n          className=\"btn-primary\"\n          disabled={!!mpcSigner}\n        >\n          {mpcSigner ? 'MPC Signer Ready' : 'Initialize MPC Signer'}\n        </button>\n\n        {mpcSigner && (\n          <button\n            onClick={createSmartSession}\n            className=\"btn-secondary\"\n            disabled={!!sessionData}\n          >\n            {sessionData ? 'Session Created' : 'Create Smart Session'}\n          </button>\n        )}\n\n        {sessionData && (\n          <button\n            onClick={executeTransaction}\n            className=\"btn-success\"\n          >\n            Execute Transaction\n          </button>\n        )}\n\n        {loading && <p className=\"text-blue-500\">{loading}</p>}\n        {txHash && (\n          <div className=\"mt-4 p-4 bg-gray-100 rounded\">\n            <p className=\"font-mono break-words\">Transaction Hash: {txHash}</p>\n          </div>\n        )}\n\n        <div className=\"mt-8 space-y-2\">\n          {mpcSigner && (\n            <p>MPC Signer Address: {mpcSigner.address}</p>\n          )}\n          {sessionData && (\n            <p>Session Granter: {parse(sessionData).granter}</p>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 551, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}