{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/browserWallet.ts"],"sourcesContent":["// lib/browserWallet.ts\nimport { TypedData, IBrowserWallet } from '@silencelaboratories/walletprovider-sdk';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { hashTypedData, hexToBytes, serializeSignature } from 'viem';\nimport { toHex } from 'viem/utils';\nimport { Buffer } from 'buffer';\n\nexport class BrowserWallet implements IBrowserWallet {\n  private privateKey: Uint8Array;\n\n  constructor(privateKeyHex: string) {\n    this.privateKey = Uint8Array.from(Buffer.from(privateKeyHex.replace(/^0x/, ''), 'hex'));\n  }\n\n  async signTypedData<T>(from: string, request: TypedData<T>): Promise<unknown> {\n    const castedRequest = {\n      ...request,\n      message: request.message as Record<string, unknown>,\n    };\n\n    // Create a hash of the typed data.\n    const messageHash = hashTypedData(castedRequest);\n    const messageBytes = hexToBytes(messageHash);\n\n    // Sign the hash.\n    const signature = secp256k1.sign(messageBytes, this.privateKey);\n\n    return serializeSignature({\n      r: toHex(signature.r),\n      s: toHex(signature.s),\n      v: BigInt(signature.recovery) + BigInt(27),\n    });\n  }\n}\n"],"names":[],"mappings":"AAAA,uBAAuB;;;;AAKvB;AAFA;AAAA;AADA;AACA;AACA;;;;;AAGO,MAAM;IACH,WAAuB;IAE/B,YAAY,aAAqB,CAAE;QACjC,IAAI,CAAC,UAAU,GAAG,WAAW,IAAI,CAAC,8JAAA,CAAA,SAAM,CAAC,IAAI,CAAC,cAAc,OAAO,CAAC,OAAO,KAAK;IAClF;IAEA,MAAM,cAAiB,IAAY,EAAE,OAAqB,EAAoB;QAC5E,MAAM,gBAAgB;YACpB,GAAG,OAAO;YACV,SAAS,QAAQ,OAAO;QAC1B;QAEA,mCAAmC;QACnC,MAAM,cAAc,CAAA,GAAA,sKAAA,CAAA,gBAAa,AAAD,EAAE;QAClC,MAAM,eAAe,CAAA,GAAA,+JAAA,CAAA,aAAU,AAAD,EAAE;QAEhC,iBAAiB;QACjB,MAAM,YAAY,wJAAA,CAAA,YAAS,CAAC,IAAI,CAAC,cAAc,IAAI,CAAC,UAAU;QAE9D,OAAO,CAAA,GAAA,2KAAA,CAAA,qBAAkB,AAAD,EAAE;YACxB,GAAG,CAAA,GAAA,6JAAA,CAAA,QAAK,AAAD,EAAE,UAAU,CAAC;YACpB,GAAG,CAAA,GAAA,6JAAA,CAAA,QAAK,AAAD,EAAE,UAAU,CAAC;YACpB,GAAG,OAAO,UAAU,QAAQ,IAAI,OAAO;QACzC;IACF;AACF"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/sl.ts"],"sourcesContent":["// lib/silenceLabs.ts\nimport { v4 as uuidv4 } from \"uuid\";\nimport { LocalAccount, privateKeyToAccount, publicKeyToAddress, toAccount } from 'viem/accounts';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport {\n    Address,\n    hashMessage,\n    hashTypedData,\n    keccak256,\n    serializeSignature,\n    serializeTransaction,\n    Signature,\n    toHex,\n  } from 'viem';\n  import { Base64 } from 'js-base64';\n\nimport { \n  WalletProviderServiceClient,\n  EOAAuth,\n  EphKeyClaim,\n  generateEphPrivateKey,\n  getEphPublicKey,\n  NetworkSigner,\n  SignRequestBuilder,\n  computeAddress,\n  SignResponse,\n} from \"@silencelaboratories/walletprovider-sdk\";\nimport { BrowserWallet } from \"./browserWallet\";\n\n// Silence Labs cluster configuration (update if needed)\nconst clusterConfig = {\n  walletProviderId: \"WalletProvider\",\n  walletProviderUrl: \"ws://34.118.117.249\", // Replace with your endpoint\n  apiVersion: \"v1\",\n};\n\nconst THRESHOLD = 2;\nconst PARTIES_NUMBER = 3;\n\nexport async function createSilenceLabsSigner(): Promise<any> {\n  const demoWalletPrivateKey = \"0x6b17d0ae446c070ce14b12990cc10f5fcf89d3410277abea6f00352535502393\";\n  const browserWallet = new BrowserWallet(demoWalletPrivateKey);\n  const account = privateKeyToAccount(\"0x6b17d0ae446c070ce14b12990cc10f5fcf89d3410277abea6f00352535502393\");\n  const ownerAddress = account.address;\n\n  // Generate an ephemeral key for signing\n  const algSign = \"secp256k1\"; // Changed to string for ephemeral key generation\n  const ephemeralPrivateKey = generateEphPrivateKey(algSign);\n  const ephemeralPublicKey = getEphPublicKey(ephemeralPrivateKey, algSign);\n  const ephId = uuidv4();\n  const ephClaim = new EphKeyClaim(ephId, ephemeralPublicKey, algSign, 60 * 60);\n\n  // Create the EOAAuth instance using the BrowserWallet\n  const eoaAuth = new EOAAuth(ownerAddress, browserWallet, { ephClaim });\n\n  // Create the wallet provider service client\n  const walletProviderClient = new WalletProviderServiceClient({\n    walletProviderId: \"WalletProvider\",\n    walletProviderUrl: \"ws://34.118.117.249\",\n    apiVersion: \"v1\",\n  });\n\n  // Create the NetworkSigner instance\n  const networkSigner = new NetworkSigner(walletProviderClient, THRESHOLD, PARTIES_NUMBER, eoaAuth);\n  const signAlg = \"secp256k1\";\n  // Perform key generation without permission arguments\n  const keygenResponse = await networkSigner.generateKey([signAlg]); // Changed to remove algSign\n  console.log(\"Silence Labs keygen response:\", keygenResponse);\n\n  return { networkSigner, keygenResponse };\n}\n\nexport function createViemAccount(\n    networkSigner: NetworkSigner,\n    keyId: string,\n    publicKey: string,\n    signAlg: string = 'secp256k1',\n  ): LocalAccount {\n    \n    const publicKeyHex = `0x${publicKey}`; // Ensure proper hex format\n    const address = publicKeyToAddress(publicKeyHex as `0x${string}`);\n    console.log(\"Generated MPC Address:\", address); // Debug log\n    console.log(\"Address:\", address);\n    return toAccount({\n      address,\n      keyId,\n      async signMessage({ message }) {\n        const signRequest = new SignRequestBuilder().setRequest(address, hashMessage(message), 'EIP191').build();\n        console.log(\"Sign Request signMessage\", signRequest);\n        const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n        console.log(\"Sign:\", sign);\n        if (sign) {\n          const signature = formatViemSign(sign);\n          return serializeSignature(signature);\n        }\n        throw new Error('No signature returned from network');\n      },\n      async signTransaction(transaction, args) {\n        console.log(\"Sign Transaction\", transaction);\n        const serializer = args?.serializer || serializeTransaction;\n        const signableTransaction = (() => {\n          // For EIP-4844 Transactions, we want to sign the transaction payload body (tx_payload_body) without the sidecars (ie. without the network wrapper).\n          // See: https://github.com/ethereum/EIPs/blob/e00f4daa66bd56e2dbd5f1d36d09fd613811a48b/EIPS/eip-4844.md#networking\n          if (transaction.type === 'eip4844') {\n            return {\n              ...transaction,\n              sidecars: false,\n            };\n          }\n          return transaction;\n        })();\n  \n        const signRequest = new SignRequestBuilder()\n          .setRequest(address, keccak256(serializer(signableTransaction)), 'EIP191')\n          .build();\n        const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n        if (sign) {\n          const signature = formatViemSign(sign);\n          return serializer(transaction, signature);\n        }\n        throw new Error('No signature returned from network');\n      },\n      async signTypedData(typedData) {\n        console.log(\"Sign Typed Data\", typedData);\n        const signRequest = new SignRequestBuilder().setRequest(address, hashTypedData(typedData), 'EIP712').build();\n        const sign = (await networkSigner.signMessage(keyId, signAlg, signRequest))[0];\n        if (sign) {\n          const signature = formatViemSign(sign);\n          return serializeSignature(signature);\n        }\n        throw new Error('No signature returned from network');\n      },\n    });\n  }\n\n  function formatViemSign(signResp: SignResponse): Signature {\n    const signb64 = signResp.sign;\n    const sign = Base64.decode(signb64);\n    const r = toHex(sign.slice(0, 32));\n    const s = toHex(sign.slice(32, 64));\n    const recid = signResp.recid;\n    const signature: Signature = {\n      r,\n      s,\n      v: recid === 0 ? BigInt(27) : BigInt(28),\n      yParity: recid,\n    };\n    return signature;\n  }\n  "],"names":[],"mappings":"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"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 194, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/lib/biconomy.ts"],"sourcesContent":["import {\n  createSmartAccountClient,\n  toNexusAccount,\n  smartSessionCreateActions,\n  smartSessionUseActions,\n  toSmartSessionsValidator,\n  stringify,\n  parse\n} from \"@biconomy/abstractjs\";\nimport { baseSepolia, sepolia } from \"viem/chains\";\nimport { encodeFunctionData, http, type Hex } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { createSilenceLabsSigner, createViemAccount } from \"./sl\";\nimport { SmartSessionMode } from \"@rhinestone/module-sdk/module\"\n\nconst COUNTER_ADDRESS = \"0xd9145CCE52D386f254917e481eB44e9943F39138\";\nconst BUNDLER_URL = \"https://paymaster.biconomy.io/api/v1/11155111/J51Gd5gX3.fca10d8b-6619-4ed3-a580-3ce21fc0d717\";\n\nexport interface SessionData {\n  granter: string;\n  sessionPublicKey: string;\n  description?: string;\n  moduleData: {\n    permissionIds: string[];\n    validUntil: number;\n    mode: `0x${string}`;\n  };\n  mpcAccount: any;\n  networkSigner: any;\n}\n\nexport async function createOwnerClient() {\n  const ownerAccount = privateKeyToAccount(\"0x6b17d0ae446c070ce14b12990cc10f5fcf89d3410277abea6f00352535502393\");\n  \n  return createSmartAccountClient({\n    account: await toNexusAccount({\n      signer: ownerAccount,\n      chain: sepolia,\n      transport: http()\n    }),\n    transport: http(BUNDLER_URL)\n  });\n}\n\nexport async function setupMPCSession(ownerClient: any) {\n  const { networkSigner, keygenResponse } = await createSilenceLabsSigner();\n  \n  if (!keygenResponse?.[0]) throw new Error(\"Invalid MPC key response\");\n  \n  const mpcAccount = createViemAccount(\n    networkSigner,\n    keygenResponse[0].keyId,\n    keygenResponse[0].publicKey,\n    'secp256k1'\n  );\n\n  const sessionsModule = toSmartSessionsValidator({\n    account: ownerClient.account,\n    signer: ownerClient.account.signer\n  });\n\n  const installHash = await ownerClient.installModule({\n    module: sessionsModule.moduleInitData\n  });\n  \n  await ownerClient.waitForUserOperationReceipt({ hash: installHash });\n\n  const extendedClient = ownerClient.extend(\n    smartSessionCreateActions(sessionsModule)\n  );\n\n  return { extendedClient, mpcAccount, networkSigner, keygenResponse };\n}\n\nexport async function createSessionClient(sessionData: SessionData) {\n  const client = createSmartAccountClient({\n    account: await toNexusAccount({\n      signer: sessionData.mpcAccount,\n      chain: sepolia,\n      transport: http(),\n    }),\n    transport: http(BUNDLER_URL)\n  });\n\n  const useModule = toSmartSessionsValidator({\n    account: client.account,\n    signer: sessionData.mpcAccount,\n  });\n\n  return client.extend(smartSessionUseActions(useModule));\n}"],"names":[],"mappings":";;;;;AAYA;AADA;AAXA;AAAA;AASA;AACA;AAVA;AAAA;;;;;;AAeA,MAAM,kBAAkB;AACxB,MAAM,cAAc;AAeb,eAAe;IACpB,MAAM,eAAe,CAAA,GAAA,kKAAA,CAAA,sBAAmB,AAAD,EAAE;IAEzC,OAAO,CAAA,GAAA,iMAAA,CAAA,2BAAwB,AAAD,EAAE;QAC9B,SAAS,MAAM,CAAA,GAAA,wLAAA,CAAA,iBAAc,AAAD,EAAE;YAC5B,QAAQ;YACR,OAAO,mKAAA,CAAA,UAAO;YACd,WAAW,CAAA,GAAA,gKAAA,CAAA,OAAI,AAAD;QAChB;QACA,WAAW,CAAA,GAAA,gKAAA,CAAA,OAAI,AAAD,EAAE;IAClB;AACF;AAEO,eAAe,gBAAgB,WAAgB;IACpD,MAAM,EAAE,aAAa,EAAE,cAAc,EAAE,GAAG,MAAM,CAAA,GAAA,4GAAA,CAAA,0BAAuB,AAAD;IAEtE,IAAI,CAAC,gBAAgB,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM;IAE1C,MAAM,aAAa,CAAA,GAAA,4GAAA,CAAA,oBAAiB,AAAD,EACjC,eACA,cAAc,CAAC,EAAE,CAAC,KAAK,EACvB,cAAc,CAAC,EAAE,CAAC,SAAS,EAC3B;IAGF,MAAM,iBAAiB,CAAA,GAAA,4NAAA,CAAA,2BAAwB,AAAD,EAAE;QAC9C,SAAS,YAAY,OAAO;QAC5B,QAAQ,YAAY,OAAO,CAAC,MAAM;IACpC;IAEA,MAAM,cAAc,MAAM,YAAY,aAAa,CAAC;QAClD,QAAQ,eAAe,cAAc;IACvC;IAEA,MAAM,YAAY,2BAA2B,CAAC;QAAE,MAAM;IAAY;IAElE,MAAM,iBAAiB,YAAY,MAAM,CACvC,CAAA,GAAA,uOAAA,CAAA,4BAAyB,AAAD,EAAE;IAG5B,OAAO;QAAE;QAAgB;QAAY;QAAe;IAAe;AACrE;AAEO,eAAe,oBAAoB,WAAwB;IAChE,MAAM,SAAS,CAAA,GAAA,iMAAA,CAAA,2BAAwB,AAAD,EAAE;QACtC,SAAS,MAAM,CAAA,GAAA,wLAAA,CAAA,iBAAc,AAAD,EAAE;YAC5B,QAAQ,YAAY,UAAU;YAC9B,OAAO,mKAAA,CAAA,UAAO;YACd,WAAW,CAAA,GAAA,gKAAA,CAAA,OAAI,AAAD;QAChB;QACA,WAAW,CAAA,GAAA,gKAAA,CAAA,OAAI,AAAD,EAAE;IAClB;IAEA,MAAM,YAAY,CAAA,GAAA,4NAAA,CAAA,2BAAwB,AAAD,EAAE;QACzC,SAAS,OAAO,OAAO;QACvB,QAAQ,YAAY,UAAU;IAChC;IAEA,OAAO,OAAO,MAAM,CAAC,CAAA,GAAA,uOAAA,CAAA,yBAAsB,AAAD,EAAE;AAC9C"}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///Users/yogendrasankhla/Desktop/abstractsdksl/src/app/page.tsx"],"sourcesContent":["\"use client\"\nimport { useState } from \"react\";\nimport { encodeFunctionData } from \"viem\";\nimport { createOwnerClient, setupMPCSession, createSessionClient, type SessionData } from \"../../lib/biconomy\";\nimport IncrementerABI from \"../../contracts/ABI.json\";\nimport styles from \"./page.module.css\";\n\nexport default function Home() {\n  const [txHash, setTxHash] = useState<string | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [step, setStep] = useState(0);\n  const [sessionData, setSessionData] = useState<SessionData | null>(null);\n\n  const initializeSession = async () => {\n    setLoading(true);\n    try {\n      setStep(1);\n      const ownerClient = await createOwnerClient();\n\n      setStep(2);\n      const { extendedClient, mpcAccount, keygenResponse } = await setupMPCSession(ownerClient);\n\n      setStep(3);\n      const functionSelector = encodeFunctionData({\n        abi: IncrementerABI,\n        functionName: \"increment\"\n      }).slice(0, 10) as Hex;\n\n      setStep(4);\n      const createSessionsResponse = await extendedClient.grantPermission({\n        sessionRequestedInfo: [{\n          sessionPublicKey: mpcAccount.address,\n          actionPoliciesInfo: [{\n            contractAddress: \"0xd9145CCE52D386f254917e481eB44e9943F39138\",\n            functionSelector,\n            rules: [{\n              value: 100,\n              offset: 0,\n              condition: 0\n            }]\n          }]\n        }]\n      });\n\n      await ownerClient.waitForUserOperationReceipt({\n        hash: createSessionsResponse.userOpHash\n      });\n\n      const sessionInfo: SessionData = {\n        granter: ownerClient.account.address,\n        sessionPublicKey: mpcAccount.address,\n        description: `Permission to increment counter for ${ownerClient.account.address.slice(0, 6)}`,\n        moduleData: {\n          permissionIds: createSessionsResponse.permissionIds,\n          validUntil: Math.floor(Date.now()/1000) + 3600,\n          mode: SmartSessionMode.USE\n        },\n        mpcAccount,\n        networkSigner: keygenResponse[0]\n      };\n\n      localStorage.setItem('mpcSession', stringify(sessionInfo));\n      setSessionData(sessionInfo);\n      setStep(5);\n\n    } catch (err) {\n      console.error(err);\n      setError(err instanceof Error ? err.message : \"Initialization failed\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const sendIncrementTx = async () => {\n    if (!sessionData) return;\n    setLoading(true);\n    try {\n      setStep(5);\n      const sessionClient = await createSessionClient(sessionData);\n      \n      setStep(6);\n      const userOpHash = await sessionClient.usePermission({\n        calls: [{\n          to: \"0xd9145CCE52D386f254917e481eB44e9943F39138\",\n          data: encodeFunctionData({\n            abi: IncrementerABI,\n            functionName: \"increment\"\n          })\n        }]\n      });\n\n      setTxHash(userOpHash);\n      setStep(7);\n    } catch (err) {\n      console.error(err);\n      setError(err instanceof Error ? err.message : \"Transaction failed\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // ... (keep the rest of the UI code unchanged)\n}"],"names":[],"mappings":";;;AACA;AAEA;AACA;AAFA;;AAFA;;;;;AAOe,SAAS;;IACtB,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAiB;IACpD,MAAM,CAAC,SAAS,WAAW,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAiB;IAClD,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IACjC,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAsB;IAEnE,MAAM,oBAAoB;QACxB,WAAW;QACX,IAAI;YACF,QAAQ;YACR,MAAM,cAAc,MAAM,CAAA,GAAA,kHAAA,CAAA,oBAAiB,AAAD;YAE1C,QAAQ;YACR,MAAM,EAAE,cAAc,EAAE,UAAU,EAAE,cAAc,EAAE,GAAG,MAAM,CAAA,GAAA,kHAAA,CAAA,kBAAe,AAAD,EAAE;YAE7E,QAAQ;YACR,MAAM,mBAAmB,CAAA,GAAA,qKAAA,CAAA,qBAAkB,AAAD,EAAE;gBAC1C,KAAK,wFAAA,CAAA,UAAc;gBACnB,cAAc;YAChB,GAAG,KAAK,CAAC,GAAG;YAEZ,QAAQ;YACR,MAAM,yBAAyB,MAAM,eAAe,eAAe,CAAC;gBAClE,sBAAsB;oBAAC;wBACrB,kBAAkB,WAAW,OAAO;wBACpC,oBAAoB;4BAAC;gCACnB,iBAAiB;gCACjB;gCACA,OAAO;oCAAC;wCACN,OAAO;wCACP,QAAQ;wCACR,WAAW;oCACb;iCAAE;4BACJ;yBAAE;oBACJ;iBAAE;YACJ;YAEA,MAAM,YAAY,2BAA2B,CAAC;gBAC5C,MAAM,uBAAuB,UAAU;YACzC;YAEA,MAAM,cAA2B;gBAC/B,SAAS,YAAY,OAAO,CAAC,OAAO;gBACpC,kBAAkB,WAAW,OAAO;gBACpC,aAAa,CAAC,oCAAoC,EAAE,YAAY,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,IAAI;gBAC7F,YAAY;oBACV,eAAe,uBAAuB,aAAa;oBACnD,YAAY,KAAK,KAAK,CAAC,KAAK,GAAG,KAAG,QAAQ;oBAC1C,MAAM,iBAAiB,GAAG;gBAC5B;gBACA;gBACA,eAAe,cAAc,CAAC,EAAE;YAClC;YAEA,aAAa,OAAO,CAAC,cAAc,UAAU;YAC7C,eAAe;YACf,QAAQ;QAEV,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC;YACd,SAAS,eAAe,QAAQ,IAAI,OAAO,GAAG;QAChD,SAAU;YACR,WAAW;QACb;IACF;IAEA,MAAM,kBAAkB;QACtB,IAAI,CAAC,aAAa;QAClB,WAAW;QACX,IAAI;YACF,QAAQ;YACR,MAAM,gBAAgB,MAAM,CAAA,GAAA,kHAAA,CAAA,sBAAmB,AAAD,EAAE;YAEhD,QAAQ;YACR,MAAM,aAAa,MAAM,cAAc,aAAa,CAAC;gBACnD,OAAO;oBAAC;wBACN,IAAI;wBACJ,MAAM,CAAA,GAAA,qKAAA,CAAA,qBAAkB,AAAD,EAAE;4BACvB,KAAK,wFAAA,CAAA,UAAc;4BACnB,cAAc;wBAChB;oBACF;iBAAE;YACJ;YAEA,UAAU;YACV,QAAQ;QACV,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC;YACd,SAAS,eAAe,QAAQ,IAAI,OAAO,GAAG;QAChD,SAAU;YACR,WAAW;QACb;IACF;AAEA,+CAA+C;AACjD;GAhGwB;KAAA"}},
    {"offset": {"line": 390, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}